import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as r,f as n}from"./app-Gq6XPTBq.js";const i={},h=n('<h1 id="python算法刷题语法快速恢复" tabindex="-1"><a class="header-anchor" href="#python算法刷题语法快速恢复" aria-hidden="true">#</a> Python算法刷题语法快速恢复</h1><h2 id="关键词" tabindex="-1"><a class="header-anchor" href="#关键词" aria-hidden="true">#</a> 关键词</h2><p>and 与<br> or 或<br> not 非<br> is 等于（比较对象）<br> == 等于（比较值）<br> True 真<br> False 假<br> None 空</p><h2 id="选择" tabindex="-1"><a class="header-anchor" href="#选择" aria-hidden="true">#</a> 选择</h2><p>n1 = int(num1[i]) if i &gt;= 0 else 0<br> return True if len(stack) == 0 else False<br> if root in (None, p, q): return root</p><h2 id="循环" tabindex="-1"><a class="header-anchor" href="#循环" aria-hidden="true">#</a> 循环</h2><p>while xxx:<br> for item in nums:<br> for index, item in enumerate(nums):<br> for i in range(n)： # 从0到（n-1）<br> for i in range(1, len(prices)): # 从1到（len-1）<br> for _ in range(len(q)): # 如果不需要用到遍历的值，用“_”</p><h2 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划" aria-hidden="true">#</a> 动态规划</h2><h3 id="上三角-下三角-按长度大小进行迭代-从左下角或右上角开始" tabindex="-1"><a class="header-anchor" href="#上三角-下三角-按长度大小进行迭代-从左下角或右上角开始" aria-hidden="true">#</a> 上三角/下三角 （按长度大小进行迭代，从左下角或右上角开始）</h3><p>for L in range(2,n+1): # 长度<br> for start in range(n): # 开始</p><h2 id="定义变量" tabindex="-1"><a class="header-anchor" href="#定义变量" aria-hidden="true">#</a> 定义变量</h2><p>res = &quot;&quot; # 1个变量<br> n1,n2,n3 = len(a1),len(a2),0 # 多个变量<br> slow = fast = head # 2个赋相同值</p><h2 id="实例化对象" tabindex="-1"><a class="header-anchor" href="#实例化对象" aria-hidden="true">#</a> 实例化对象</h2><p>h = ListNode(0, None) # 前面不加new</p><h2 id="通用函数" tabindex="-1"><a class="header-anchor" href="#通用函数" aria-hidden="true">#</a> 通用函数</h2><p>len(xxx) # 求长度<br> str(xxx) # 转字符串<br> int(xxx) # 转整型<br> min(xxx)<br> max(xxx)</p><h2 id="字符函数" tabindex="-1"><a class="header-anchor" href="#字符函数" aria-hidden="true">#</a> 字符函数</h2><p>c.lower() # 转小写<br> c.isalnum() # 是字母或数字</p><h2 id="计算符" tabindex="-1"><a class="header-anchor" href="#计算符" aria-hidden="true">#</a> 计算符</h2><p>// 整除（得到整数）<br> / 除法（得到小数）</p><p>每行结尾不用加；<br> 递归，方法前要加self.</p><h2 id="词典-哈希表" tabindex="-1"><a class="header-anchor" href="#词典-哈希表" aria-hidden="true">#</a> 词典/哈希表</h2><p>dict = {} # 定义<br> dict[target-item] # 取值<br> dict[item] = index # 赋值<br> if target-item in dict # 判断key是否存在</p><h2 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串" aria-hidden="true">#</a> 字符串</h2><p>“00123”.lstrip(0) # 去掉前缀0<br> s[::-1] # 反转</p><h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h2><p>dp = [0 for _ in range(size)] # 定义方式1<br> dp[i] = 5 # 添加方式1（只有初始化长度足够，这样赋值才不会索引越界）</p><p>res = list() # 定义方式2<br> res.append(xxx) # 添加方式2（添加不能是res[i]=5的方式赋值）</p><p>res[i] # 取<br> res[::-1] # 反转</p><h2 id="二维数组" tabindex="-1"><a class="header-anchor" href="#二维数组" aria-hidden="true">#</a> 二维数组</h2><p>dp = [[False] * n for _ in range(n)] # 定义<br> dp[i][j] # 存取<br> s[begin: begin+max_len] # 子串，左闭右开</p><h3 id="二维数组排序" tabindex="-1"><a class="header-anchor" href="#二维数组排序" aria-hidden="true">#</a> 二维数组排序</h3><p>sorted不在原有数组上排序，生成新的数组<br> array = sorted(array, key=lambda x:(x[0],x[1])) # 按第一个元素升序，再按第二个元素升序<br> array = sorted(array, key=lambda x: (x[0], -x[1])) # 按第一个元素升序，再按第二个元素降序</p><p>sort在原有数组上排序<br> array.sort(key=lambda x:(x[0],x[1]))<br> array.sort(key=lambda x:(x[0],-x[1]))</p><h2 id="栈-同数组一样" tabindex="-1"><a class="header-anchor" href="#栈-同数组一样" aria-hidden="true">#</a> 栈（同数组一样）</h2><p>stack = list() # 定义<br> stack.append(xxx) # 存<br> stack.pop() # 取<br> stack[-1] # 栈顶</p><h2 id="队列" tabindex="-1"><a class="header-anchor" href="#队列" aria-hidden="true">#</a> 队列</h2><p>q = collections.deque() # 定义<br> q.popleft() # 出队<br> q.append() # 入队</p><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆" aria-hidden="true">#</a> 堆</h2><p>heapq</p>',40),d=[h];function t(s,o){return e(),r("div",null,d)}const b=a(i,[["render",t],["__file","python算法刷题语法快速恢复.html.vue"]]);export{b as default};
