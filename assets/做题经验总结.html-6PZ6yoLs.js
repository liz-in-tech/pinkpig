import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c as t,e as n,a as l,b as s}from"./app-I9eu-1La.js";const e="/pinkpig/assets/interview_code-zVSMCWow.png",u="/pinkpig/assets/adjacency-8P8vZkKv.png",c={},r=n('<h1 id="做题经验总结" tabindex="-1"><a class="header-anchor" href="#做题经验总结" aria-hidden="true">#</a> 做题经验总结</h1><ul><li>通用 <ul><li>先理清思路，列好整体思路大纲再着手开始写</li><li>额外定义函数作为内部函数，省去写self.,内部函数要定义在其他代码的上面，否则找不到，内部函数中可以用其他代码中定义的变量</li></ul></li><li>面试时做算法题 <ul><li>询问题目细节</li><li>把想到的几个思路和各自的时间复杂度都跟面试官说一遍</li><li>敲定一个方案后，列出思路大纲</li><li>开始写代码，最好边写边说你正在做什么</li><li>测试代码通过</li></ul></li><li>笔试做算法题 <ul><li>根据数据范围和时空复杂度要求筛选可用方案</li><li>敲定一个方案后，列出思路大纲</li><li>开始写代码</li><li>测试代码通过</li></ul></li><li>一些常用变量命名保持一致 <ul><li>pre, nxt</li><li>begin, end</li><li>slow, fast</li></ul></li></ul><h2 id="面试算法常考题型" tabindex="-1"><a class="header-anchor" href="#面试算法常考题型" aria-hidden="true">#</a> 面试算法常考题型</h2><figure><img src="'+e+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="根据数据范围和时空复杂度推断可用算法" tabindex="-1"><a class="header-anchor" href="#根据数据范围和时空复杂度推断可用算法" aria-hidden="true">#</a> 根据数据范围和时空复杂度推断可用算法</h2><p>一般ACM或者笔试题的时间限制是1秒或2秒。</p>',6),p=l("p",null,[s("C++在1秒内大约能执行"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"1"),l("msup",null,[l("mn",null,"0"),l("mn",null,"8")])]),l("annotation",{encoding:"application/x-tex"},"10^8")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8141em"}}),l("span",{class:"mord"},"1"),l("span",{class:"mord"},[l("span",{class:"mord"},"0"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.8141em"}},[l("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},"8")])])])])])])])])])]),s("次操作，因此时间复杂度小于"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"1"),l("msup",null,[l("mn",null,"0"),l("mn",null,"8")])]),l("annotation",{encoding:"application/x-tex"},"10^8")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8141em"}}),l("span",{class:"mord"},"1"),l("span",{class:"mord"},[l("span",{class:"mord"},"0"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.8141em"}},[l("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},"8")])])])])])])])])])]),s("即可接受")],-1),m=l("p",null,"根据数据范围锁定可取的时间复杂度，再根据时间复杂度筛选可用的算法",-1),h=l("ul",null,[l("li",null,[s("O(1) [可用] "),l("ul",null,[l("li",null,[l("strong",null,"哈希表")]),l("li",null,"数组访问"),l("li",null,"链表增删")])]),l("li",null,[s("O(logn) [可用] "),l("ul",null,[l("li",null,[l("strong",null,"二分查找")]),l("li",null,"快速幂"),l("li",null,"平衡二叉树操作"),l("li",null,"对数级分治")])]),l("li",null,[s("O(n) [可用] "),l("ul",null,[l("li",null,[l("strong",null,"栈/队列/单调栈/单调队列")]),l("li",null,[l("strong",null,"双指针")]),l("li",null,"单层for循环"),l("li",null,"找最大值"),l("li",null,"滑动窗口"),l("li",null,"KMP"),l("li",null,"前缀和"),l("li",null,"哈希计数"),l("li",null,"桶/计数排序")])]),l("li",null,[s("O(nlogn) [n<="),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"1"),l("msup",null,[l("mn",null,"0"),l("mn",null,"5")])]),l("annotation",{encoding:"application/x-tex"},"10^5")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8141em"}}),l("span",{class:"mord"},"1"),l("span",{class:"mord"},[l("span",{class:"mord"},"0"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.8141em"}},[l("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},"5")])])])])])])])])])]),s("可用] "),l("ul",null,[l("li",null,[l("strong",null,"堆/优先队列")]),l("li",null,[s("排序 "),l("ul",null,[l("li",null,"归并排序"),l("li",null,"快速排序")])]),l("li",null,"递归"),l("li",null,"分治"),l("li",null,"树状数组"),l("li",null,"线段树"),l("li",null,"贪心")])]),l("li",null,[s("O("),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"n"),l("mn",null,"2")])]),l("annotation",{encoding:"application/x-tex"},"n^2")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8141em"}}),l("span",{class:"mord"},[l("span",{class:"mord mathnormal"},"n"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.8141em"}},[l("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},"2")])])])])])])])])])]),s(") [n<="),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"1"),l("msup",null,[l("mn",null,"0"),l("mn",null,"4")])]),l("annotation",{encoding:"application/x-tex"},"10^4")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8141em"}}),l("span",{class:"mord"},"1"),l("span",{class:"mord"},[l("span",{class:"mord"},"0"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.8141em"}},[l("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},"4")])])])])])])])])])]),s("可用] "),l("ul",null,[l("li",null,"双重for循环"),l("li",null,"动态规划"),l("li",null,"DFS/BFS")])]),l("li",null,[s("O("),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"n"),l("mn",null,"3")])]),l("annotation",{encoding:"application/x-tex"},"n^3")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8141em"}}),l("span",{class:"mord"},[l("span",{class:"mord mathnormal"},"n"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.8141em"}},[l("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},"3")])])])])])])])])])]),s(") [n<=500可用] "),l("ul",null,[l("li",null,"Floyd 算法")])]),l("li",null,[s("O("),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mn",null,"2"),l("mi",null,"n")])]),l("annotation",{encoding:"application/x-tex"},"2^n")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6644em"}}),l("span",{class:"mord"},[l("span",{class:"mord"},"2"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.6644em"}},[l("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mathnormal mtight"},"n")])])])])])])])])])]),s(") [n<=20可用] "),l("ul",null,[l("li",null,"爬楼梯递归")])]),l("li",null,[s("O(n!) [n<=10可用] "),l("ul",null,[l("li",null,"全排列"),l("li",null,"回溯"),l("li",null,"子集生成")])])],-1),o=n(`<p>不同算法的时间复杂度</p><ul><li>循环 <ul><li>单层 O(n)</li><li>双层 O(n^2)</li></ul></li><li>排序 <ul><li>O(nlogn)</li></ul></li><li>二分查找 <ul><li>O(logn)</li></ul></li><li>递归 <ul><li>分析递归多少层，每层的复杂度</li><li>例如，归并排序为logn层，每层是O(n)复杂度，所以整体复杂度是O(nlogn)</li></ul></li><li>双指针 <ul><li>看似两层循环，但只用关注内层指针的循环次数，不超过n，所以复杂度是O(n)</li></ul></li><li>数据结构 <ul><li>链表：增删节点O(1)</li><li>栈/队列：O(1)</li><li>单调栈/单调队列：O(n)</li><li>KMP：O(n)</li><li>并查集：路径压缩最坏O(logn)，再加按秩合并O(loglogn)</li><li>堆排序：堆是完全二叉树，高度logn，加入或删除数据，复杂度与高度呈线性，O(logn)</li><li>哈希表：增删改查O(1)</li></ul></li><li>搜索问题 <ul><li>全排列：转化为树，每层结点数分别为n! (n-1)! (n-2)!</li><li>其他层相对最后一层是无穷小量，每个结点都要O(n)循环一遍数字，所以是O(n*n!)</li></ul></li><li>图论 <ul><li>图的搜索：dfs和bfs，每个点和每条边都会被遍历一次，所以O(n + m)</li><li>dijkstra算法： <ul><li>朴素版，两重循环，都循环点，O(n^2)；</li><li>堆优化：操作m次堆，O(mlogm)，且m &lt;&lt; n^2，也即O(mlogn)</li></ul></li><li>bellman-ford：循环点再循环边，O(nm)</li><li>spfa：最短路，最差O(nm)，实际快很多；判断负环，O(nm)</li><li>floyd算法：三重循环，O(n^3)</li><li>prim算法：两重循环，O(n^2)</li><li>kruskal算法：边排序O(mlogm)，遍历边O(m)，O(mlogm)</li><li>染色法：图的遍历，dfs或bfs，O(n + m)</li><li>匈牙利算法：遍历点时，遍历边，复杂度O(nm)</li></ul></li><li>数学知识 <ul><li>判断质数：O(sqrt(n))</li><li>筛质数：两重循环相关，n*调和级数，O(nlogn) <ul><li>补充：如果加优化，只筛质数倍数，O(nloglogn)</li></ul></li><li>最大公约数：O(logn)</li><li>快速幂：k二进制有多少位，循环多少次，logk</li></ul></li><li>DP <ul><li>DP计算量 = 状态数量 * 状态转移的计算量</li><li>背包问题：看循环或套公式</li><li>分组背包：状态数量nv，计算量O(n)，复杂度O(vn^2)，或者直接看三层循环</li><li>最长上升子序列Ⅱ:外层循环n次，内层二分logn次，O(nlogn)</li><li>蒙德里安的梦想：优化后，外层枚举列m，内层枚举当前列所有状态2<sup>n，m*2</sup>n</li><li>没有上司的舞会：状态数，所有边n-1，计算量O(1)，复杂度O(n)</li><li>滑雪：两维dp，状态数为n<sup>2，计算量O(1)，复杂度O(n</sup>2)</li></ul></li><li>贪心 <ul><li>排序 + 循环：O(nlogn)</li></ul></li></ul><h2 id="解题技巧汇总" tabindex="-1"><a class="header-anchor" href="#解题技巧汇总" aria-hidden="true">#</a> 解题技巧汇总</h2><h3 id="链表题解题技巧-6项" tabindex="-1"><a class="header-anchor" href="#链表题解题技巧-6项" aria-hidden="true">#</a> 链表题解题技巧(6项)</h3><p>1.哨兵节点：头节点有变动时必须用</p><p>2.快慢指针：定位特定节点</p><p>3.删除当前节点：将下一个节点的值给当前节点，并删除下一个节点</p><p>4.相交链表（2个链表的尾部重合）找相交点：2个指针到尾部后换到另一个链表上，当2个指针指向同一个节点，就是相交点</p><p>5.环形链表找环的入口点：快慢指针重合后，快指针回到原点1倍速和慢指针重逢点即入口点</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>证明
       a：入环前长度 b：入环到相遇点 c：相遇点到入环点
       slow走的距离：a + k1(b+c) + b
       fast走的距离：a + k2(b+c) + b
       2(a + k1(b+c) + b) =  a + k2(b+c) + b
       2a + 2b + 2k1(b+c) = a + b + k2(b+c)
       a = (k2-2k1) (b+c) - b
       a = (k2-2k1-1)(b+c) + c
       a = k(b+c) + c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>6.环形链表环的长度：找到环的入口点后，一个指针待在入口点，另一个指针走一圈（通过比对入口点指针知道是否走了一圈），记录下走的距离即为环的距离</p><h3 id="动态规划解题技巧-perfect" tabindex="-1"><a class="header-anchor" href="#动态规划解题技巧-perfect" aria-hidden="true">#</a> 动态规划解题技巧 (Perfect)</h3><p>1.状态定义：1）一维还是二维，2）dp[i]/dp[i][j]代表意义 3）初始状态</p><p>2.状态转移：1）转移方程，2）dp数组填入内容的顺序</p><h3 id="图论解题技巧-note-树🌲的题也用图论做" tabindex="-1"><a class="header-anchor" href="#图论解题技巧-note-树🌲的题也用图论做" aria-hidden="true">#</a> 图论解题技巧（Note:树🌲的题也用图论做）</h3><h4 id="dfs-回溯解题技巧-perfect" tabindex="-1"><a class="header-anchor" href="#dfs-回溯解题技巧-perfect" aria-hidden="true">#</a> dfs-回溯解题技巧 (Perfect)</h4><p>1.backtrack传参：</p><ul><li>只传2种参数(1种是进行到哪一步的定位，1种是回溯结束时要得到的数据)</li><li>没有返回值 2.结束条件</li></ul><p>3.每个backtrack有几种情况</p><p>4.每种情况 1）剪枝(用集合set来判断是否剪枝) 2）前置更新 3）backtrack递归调用 4）后置恢复</p><h4 id="bfs-拓扑排序-eg-课程先后顺序" tabindex="-1"><a class="header-anchor" href="#bfs-拓扑排序-eg-课程先后顺序" aria-hidden="true">#</a> bfs-拓扑排序（eg.课程先后顺序）</h4><ul><li>1.<strong>定义并构造邻接表adj(Adjacency List)和入度数列表</strong></li><li>2.将入度数为0的加入队列 (BFS)</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>adj = defaultdict(list) # 出度
enter_nums = [0] * numCourses # 入度个数
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="bfs-最短路" tabindex="-1"><a class="header-anchor" href="#bfs-最短路" aria-hidden="true">#</a> bfs-最短路</h4><p>整体思路</p><ul><li>1.是否有现成的图结构（例如地图题），如果没有，需要将问题转化为邻接表</li><li>2.把起始点加入队列</li><li>3.当队列里有节点时，记录bfs的步数step，每次把同一step的节点一并取出并放入下一步的节点</li></ul><p>特定题的技巧：</p><ul><li>将一个问题建图（数学建模），构造为邻接表</li><li>创建虚拟节点来优化建图（eg.127 单词接龙） - 依据朴素的思路，我们可以枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以优化建图。 - 具体地，我们可以<strong>创建虚拟节点</strong>。对于单词 hit，我们创建三个虚拟节点 <em>it、h</em>t、hi*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。</li></ul><figure><img src="`+u+'" alt="借助通配符构建邻接表" tabindex="0" loading="lazy"><figcaption>借助通配符构建邻接表</figcaption></figure><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2><ul><li>https://www.acwing.com/blog/content/5006/</li><li>https://www.acwing.com/blog/content/32/</li><li>https://www.acwing.com/blog/content/16975/</li></ul>',31),d=[r,p,m,h,o];function g(b,x){return i(),t("div",null,d)}const w=a(c,[["render",g],["__file","做题经验总结.html.vue"]]);export{w as default};
