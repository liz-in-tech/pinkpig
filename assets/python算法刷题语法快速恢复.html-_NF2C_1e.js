import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as r,f as n}from"./app-rvE1EVAc.js";const i={},h=n('<h1 id="python算法刷题语法快速恢复" tabindex="-1"><a class="header-anchor" href="#python算法刷题语法快速恢复" aria-hidden="true">#</a> Python算法刷题语法快速恢复</h1><h2 id="关键词" tabindex="-1"><a class="header-anchor" href="#关键词" aria-hidden="true">#</a> 关键词</h2><p>and 与 or 或 not 非 is 等于（比较对象） == 等于（比较值） True 真 False 假 None 空</p><h2 id="选择" tabindex="-1"><a class="header-anchor" href="#选择" aria-hidden="true">#</a> 选择</h2><p>n1 = int(num1[i]) if i &gt;= 0 else 0 return True if len(stack) == 0 else False if root in (None, p, q): return root</p><h2 id="循环" tabindex="-1"><a class="header-anchor" href="#循环" aria-hidden="true">#</a> 循环</h2><p>while xxx: for item in nums: for index, item in enumerate(nums): for i in range(n)： # 从0到（n-1） for i in range(1, len(prices)): # 从1到（len-1） for _ in range(len(q)): # 如果不需要用到遍历的值，用“_”</p><h2 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划" aria-hidden="true">#</a> 动态规划</h2><h3 id="上三角-下三角-按长度大小进行迭代-从左下角或右上角开始" tabindex="-1"><a class="header-anchor" href="#上三角-下三角-按长度大小进行迭代-从左下角或右上角开始" aria-hidden="true">#</a> 上三角/下三角 （按长度大小进行迭代，从左下角或右上角开始）</h3><p>for L in range(2,n+1): # 长度 for start in range(n): # 开始</p><h2 id="定义变量" tabindex="-1"><a class="header-anchor" href="#定义变量" aria-hidden="true">#</a> 定义变量</h2><p>res = &quot;&quot; # 1个变量 n1,n2,n3 = len(a1),len(a2),0 # 多个变量 slow = fast = head # 2个赋相同值</p><h2 id="实例化对象" tabindex="-1"><a class="header-anchor" href="#实例化对象" aria-hidden="true">#</a> 实例化对象</h2><p>h = ListNode(0, None) # 前面不加new</p><h2 id="通用函数" tabindex="-1"><a class="header-anchor" href="#通用函数" aria-hidden="true">#</a> 通用函数</h2><p>len(xxx) # 求长度 str(xxx) # 转字符串 int(xxx) # 转整型 min(xxx) max(xxx)</p><h2 id="字符函数" tabindex="-1"><a class="header-anchor" href="#字符函数" aria-hidden="true">#</a> 字符函数</h2><p>c.lower() # 转小写 c.isalnum() # 是字母或数字</p><h2 id="计算符" tabindex="-1"><a class="header-anchor" href="#计算符" aria-hidden="true">#</a> 计算符</h2><p>// 整除（得到整数） / 除法（得到小数）</p><p>每行结尾不用加； 递归，方法前要加self.</p><h2 id="词典-哈希表" tabindex="-1"><a class="header-anchor" href="#词典-哈希表" aria-hidden="true">#</a> 词典/哈希表</h2><p>dict = {} # 定义 dict[target-item] # 取值 dict[item] = index # 赋值 if target-item in dict # 判断key是否存在</p><h2 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串" aria-hidden="true">#</a> 字符串</h2><p>“00123”.lstrip(0) # 去掉前缀0 s[::-1] # 反转</p><h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h2><p>dp = [0 for _ in range(size)] # 定义方式1 dp[i] = 5 # 添加方式1（只有初始化长度足够，这样赋值才不会索引越界）</p><p>res = list() # 定义方式2 res.append(xxx) # 添加方式2（添加不能是res[i]=5的方式赋值）</p><p>res[i] # 取 res[::-1] # 反转</p><h2 id="二维数组" tabindex="-1"><a class="header-anchor" href="#二维数组" aria-hidden="true">#</a> 二维数组</h2><p>dp = [[False] * n for _ in range(n)] # 定义 dp[i][j] # 存取 s[begin: begin+max_len] # 子串，左闭右开</p><h3 id="二维数组排序" tabindex="-1"><a class="header-anchor" href="#二维数组排序" aria-hidden="true">#</a> 二维数组排序</h3><p>sorted不在原有数组上排序，生成新的数组 array = sorted(array, key=lambda x:(x[0],x[1])) # 按第一个元素升序，再按第二个元素升序 array = sorted(array, key=lambda x: (x[0], -x[1])) # 按第一个元素升序，再按第二个元素降序</p><p>sort在原有数组上排序<br> array.sort(key=lambda x:(x[0],x[1])) array.sort(key=lambda x:(x[0],-x[1]))</p><h2 id="栈-同数组一样" tabindex="-1"><a class="header-anchor" href="#栈-同数组一样" aria-hidden="true">#</a> 栈（同数组一样）</h2><p>stack = list() # 定义 stack.append(xxx) # 存 stack.pop() # 取 stack[-1] # 栈顶</p><h2 id="队列" tabindex="-1"><a class="header-anchor" href="#队列" aria-hidden="true">#</a> 队列</h2><p>q = collections.deque() # 定义 q.popleft() # 出队 q.append() # 入队</p><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆" aria-hidden="true">#</a> 堆</h2><p>heapq</p>',40),d=[h];function t(s,o){return e(),r("div",null,d)}const x=a(i,[["render",t],["__file","python算法刷题语法快速恢复.html.vue"]]);export{x as default};
