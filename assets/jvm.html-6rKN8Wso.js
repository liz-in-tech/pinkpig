const e=JSON.parse('{"key":"v-7175977a","path":"/java/jvm/jvm.html","title":"JVM","lang":"en-US","frontmatter":{"icon":"lightbulb","description":"JVM 1、概述 Java技术体系 优点 平台无关性&amp;语言无关性 平台无关性 一次编译，到处运行 各硬件平台有针对性的JVM，可以将同一份字节码文件解释为对应平台的机器码 语言无关性 任何能编译成字节码文件的语言，都能被JVM运行。JVM 只认识 .class 文件，它不关心是何种语言生成了 .class 文件，只要 .class 文件符合 JVM 的规范就能运行。 目前已经有 JRuby、Jython、Scala 等语言能够在 JVM 上运行。它们有各自的语法规则，不过它们的编译器都能将各自的源码编译成符合 JVM 规范的 .class 文件，从而能够借助 JVM 运行它们。","head":[["meta",{"property":"og:url","content":"https://liz-in-tech.github.io/pinkpig/java/jvm/jvm.html"}],["meta",{"property":"og:site_name","content":"Liz"}],["meta",{"property":"og:title","content":"JVM"}],["meta",{"property":"og:description","content":"JVM 1、概述 Java技术体系 优点 平台无关性&amp;语言无关性 平台无关性 一次编译，到处运行 各硬件平台有针对性的JVM，可以将同一份字节码文件解释为对应平台的机器码 语言无关性 任何能编译成字节码文件的语言，都能被JVM运行。JVM 只认识 .class 文件，它不关心是何种语言生成了 .class 文件，只要 .class 文件符合 JVM 的规范就能运行。 目前已经有 JRuby、Jython、Scala 等语言能够在 JVM 上运行。它们有各自的语法规则，不过它们的编译器都能将各自的源码编译成符合 JVM 规范的 .class 文件，从而能够借助 JVM 运行它们。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-02-16T15:28:18.000Z"}],["meta",{"property":"article:author","content":"Liz"}],["meta",{"property":"article:modified_time","content":"2025-02-16T15:28:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-16T15:28:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Liz\\",\\"url\\":\\"https://github.com/liz-in-tech\\"}]}"]]},"headers":[{"level":2,"title":"1、概述","slug":"_1、概述","link":"#_1、概述","children":[{"level":3,"title":"Java技术体系","slug":"java技术体系","link":"#java技术体系","children":[]},{"level":3,"title":"JDK、JRE、JVM","slug":"jdk、jre、jvm","link":"#jdk、jre、jvm","children":[]},{"level":3,"title":"Java发展史","slug":"java发展史","link":"#java发展史","children":[]},{"level":3,"title":"Java虚拟机","slug":"java虚拟机","link":"#java虚拟机","children":[]}]},{"level":2,"title":"2、类加载机制","slug":"_2、类加载机制","link":"#_2、类加载机制","children":[{"level":3,"title":"Class文件结构","slug":"class文件结构","link":"#class文件结构","children":[]},{"level":3,"title":"类加载过程/类的生命周期","slug":"类加载过程-类的生命周期","link":"#类加载过程-类的生命周期","children":[]},{"level":3,"title":"类加载器","slug":"类加载器","link":"#类加载器","children":[]}]},{"level":2,"title":"3、自动内存管理","slug":"_3、自动内存管理","link":"#_3、自动内存管理","children":[{"level":3,"title":"内存区域划分","slug":"内存区域划分","link":"#内存区域划分","children":[]},{"level":3,"title":"内存分配","slug":"内存分配","link":"#内存分配","children":[]},{"level":3,"title":"内存回收","slug":"内存回收","link":"#内存回收","children":[]},{"level":3,"title":"内存泄漏、内存溢出","slug":"内存泄漏、内存溢出","link":"#内存泄漏、内存溢出","children":[]},{"level":3,"title":"JVM调优","slug":"jvm调优","link":"#jvm调优","children":[]}]},{"level":2,"title":"4、怎么回收","slug":"_4、怎么回收","link":"#_4、怎么回收","children":[{"level":3,"title":"垃圾收集算法","slug":"垃圾收集算法","link":"#垃圾收集算法","children":[]},{"level":3,"title":"评估","slug":"评估","link":"#评估","children":[]},{"level":3,"title":"选择方案","slug":"选择方案","link":"#选择方案","children":[]}]}],"git":{"createdTime":1730220137000,"updatedTime":1739719698000,"contributors":[{"name":"liz","email":"liz@MacBook-Pro.local","commits":3},{"name":"unknown","email":"15721607377@163.com","commits":1}]},"readingTime":{"minutes":54.45,"words":16335},"filePathRelative":"java/jvm/jvm.md","localizedDate":"October 29, 2024","excerpt":"<h1> JVM</h1>\\n<h2> 1、概述</h2>\\n<h3> Java技术体系</h3>\\n<h4> 优点</h4>\\n<h5> 平台无关性&amp;语言无关性</h5>\\n<figure><figcaption></figcaption></figure>\\n<h6> 平台无关性</h6>\\n<p>一次编译，到处运行</p>\\n<p>各硬件平台有针对性的JVM，可以将同一份字节码文件解释为对应平台的机器码</p>\\n<h6> 语言无关性</h6>\\n<p>任何能编译成字节码文件的语言，都能被JVM运行。JVM 只认识 .class 文件，它不关心是何种语言生成了 .class 文件，只要 .class 文件符合 JVM 的规范就能运行。 目前已经有 JRuby、Jython、Scala 等语言能够在 JVM 上运行。它们有各自的语法规则，不过它们的编译器都能将各自的源码编译成符合 JVM 规范的 .class 文件，从而能够借助 JVM 运行它们。</p>","autoDesc":true}');export{e as data};
