const e=JSON.parse('{"key":"v-5c8fd235","path":"/cs/code/algorithm/4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html","title":"二分查找","lang":"en-US","frontmatter":{"icon":"lightbulb","description":"二分查找 对数列的要求 有序的（排好序的，无序的需要提前排序） 存在上下界（限定数量或区间范围。否则需要对不定长的边界做处理，来找到明确上下界） 能够通过索引访问其中的元素（数组适合，链表非常不适合） 不常变动的，不要求动态增删的情形下查找（否则，应采用AVL树，即自平衡的二叉查找树） 数据量不能超级大（针对实际应用，要考虑内存限制） 数据量太大就不适合二分查找了。 二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空 间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存 储，那就需要 1GB 的连续内存空间。 注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组 存储就比较吃力了，也就不能用二分查找了。","head":[["meta",{"property":"og:url","content":"https://liz-in-tech.github.io/pinkpig/cs/code/algorithm/4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"}],["meta",{"property":"og:site_name","content":"Liz"}],["meta",{"property":"og:title","content":"二分查找"}],["meta",{"property":"og:description","content":"二分查找 对数列的要求 有序的（排好序的，无序的需要提前排序） 存在上下界（限定数量或区间范围。否则需要对不定长的边界做处理，来找到明确上下界） 能够通过索引访问其中的元素（数组适合，链表非常不适合） 不常变动的，不要求动态增删的情形下查找（否则，应采用AVL树，即自平衡的二叉查找树） 数据量不能超级大（针对实际应用，要考虑内存限制） 数据量太大就不适合二分查找了。 二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空 间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存 储，那就需要 1GB 的连续内存空间。 注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组 存储就比较吃力了，也就不能用二分查找了。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-10-29T16:42:17.000Z"}],["meta",{"property":"article:author","content":"Liz"}],["meta",{"property":"article:modified_time","content":"2024-10-29T16:42:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二分查找\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-29T16:42:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Liz\\",\\"url\\":\\"https://github.com/liz-in-tech\\"}]}"]]},"headers":[{"level":2,"title":"对数列的要求","slug":"对数列的要求","link":"#对数列的要求","children":[]},{"level":2,"title":"复杂度分析","slug":"复杂度分析","link":"#复杂度分析","children":[]},{"level":2,"title":"不定长的边界的处理","slug":"不定长的边界的处理","link":"#不定长的边界的处理","children":[]},{"level":2,"title":"while(left <= right)和while(left < right)","slug":"while-left-right-和while-left-right","link":"#while-left-right-和while-left-right","children":[]},{"level":2,"title":"分类（前提：有序数据集合中不存在重复的数据）","slug":"分类-前提-有序数据集合中不存在重复的数据","link":"#分类-前提-有序数据集合中不存在重复的数据","children":[{"level":3,"title":"整数二分","slug":"整数二分","link":"#整数二分","children":[]},{"level":3,"title":"浮点数二分","slug":"浮点数二分","link":"#浮点数二分","children":[]}]},{"level":2,"title":"二分查找变体（前提：有序数据集合中存在重复的数据）","slug":"二分查找变体-前提-有序数据集合中存在重复的数据","link":"#二分查找变体-前提-有序数据集合中存在重复的数据","children":[{"level":3,"title":"查找第一个值等于给定值的元素","slug":"查找第一个值等于给定值的元素","link":"#查找第一个值等于给定值的元素","children":[]},{"level":3,"title":"查找最后一个值等于给定值的元素","slug":"查找最后一个值等于给定值的元素","link":"#查找最后一个值等于给定值的元素","children":[]},{"level":3,"title":"查找第一个大于等于给定值的元素","slug":"查找第一个大于等于给定值的元素","link":"#查找第一个大于等于给定值的元素","children":[]},{"level":3,"title":"查找最后一个小于等于给定值的元素","slug":"查找最后一个小于等于给定值的元素","link":"#查找最后一个小于等于给定值的元素","children":[]}]}],"git":{"createdTime":1730220137000,"updatedTime":1730220137000,"contributors":[{"name":"unknown","email":"15721607377@163.com","commits":1}]},"readingTime":{"minutes":5.28,"words":1583},"filePathRelative":"cs/code/algorithm/4.二分查找.md","localizedDate":"October 29, 2024","excerpt":"<h1> 二分查找</h1>\\n<h2> 对数列的要求</h2>\\n<ol>\\n<li>有序的（排好序的，无序的需要提前排序） <br></li>\\n<li>存在上下界（限定数量或区间范围。否则需要对不定长的边界做处理，来找到明确上下界） <br></li>\\n<li>能够通过索引访问其中的元素（数组适合，链表非常不适合） <br></li>\\n<li>不常变动的，不要求动态增删的情形下查找（否则，应采用AVL树，即自平衡的二叉查找树） <br></li>\\n<li>数据量不能超级大（针对实际应用，要考虑内存限制） <br></li>\\n</ol>\\n<p>数据量太大就不适合二分查找了。 <br>\\n二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空 间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存 储，那就需要 1GB 的连续内存空间。   <br>\\n注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组 存储就比较吃力了，也就不能用二分查找了。   <br></p>","autoDesc":true}');export{e as data};
