import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as r,e as i}from"./app-HpbQfhZE.js";const h="/pinkpig/assets/redis_001-JdU70FGV.png",d="/pinkpig/assets/redis_002-Ko_LIIqP.png",s="/pinkpig/assets/redis_003-RktbmFte.png",n="/pinkpig/assets/redis_004-qc_IvHGZ.png",t="/pinkpig/assets/redis_005-d3cPOW5Q.png",p="/pinkpig/assets/redis_006-V50cRAbx.png",c="/pinkpig/assets/redis_007-fAHw1aQA.png",o="/pinkpig/assets/redis_008-0x6mjNts.png",l="/pinkpig/assets/redis_009-NulFxVOC.png",f="/pinkpig/assets/redis_010-hkBQn2H2.png",u={},b=i('<h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h1><h2 id="redis为什么快" tabindex="-1"><a class="header-anchor" href="#redis为什么快" aria-hidden="true">#</a> Redis为什么快</h2><p>基于内存运行</p><p>c语言实现，更接近底层操作</p><p>源码精湛简短</p><p>数据结构专门设计，底层做了优化</p><h3 id="redis是单线程-worker线程始终是单线程" tabindex="-1"><a class="header-anchor" href="#redis是单线程-worker线程始终是单线程" aria-hidden="true">#</a> Redis是单线程（worker线程始终是单线程）</h3><p>Redis5.x版本及之前是单线程的工作机制，worker既处理IO又处理计算，按顺序串行执行。</p><p>Redis6.0版本之后，推出了多线程概念，多个IO子线程处理IO读写，worker仅处理计算，性能提高。</p><h4 id="单线程与多线程适用场景" tabindex="-1"><a class="header-anchor" href="#单线程与多线程适用场景" aria-hidden="true">#</a> 单线程与多线程适用场景</h4><p>一个请求处理很快，但这个请求数量很多，适合用单线程。eg.redis存取key；nginx请求转发。</p><p>业务处理复杂，一个请求过来需要处理很长时间，适合用多线程。</p><h3 id="io多路复用-非阻塞io" tabindex="-1"><a class="header-anchor" href="#io多路复用-非阻塞io" aria-hidden="true">#</a> IO多路复用（非阻塞IO）</h3><p>IO多路复用，针对单线程，可以让单线程高效的处理多个网络连接请求，尽量减少网络IO的时间消耗。</p><p>内部实现采用epoll。epoll自己实现了简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在IO上浪费一点时间。</p><h4 id="io多路复用" tabindex="-1"><a class="header-anchor" href="#io多路复用" aria-hidden="true">#</a> IO多路复用</h4><h5 id="内核态判断是否有数据-没数据时阻塞。" tabindex="-1"><a class="header-anchor" href="#内核态判断是否有数据-没数据时阻塞。" aria-hidden="true">#</a> 内核态判断是否有数据，没数据时阻塞。</h5><p>基于连接轮询机制：把连接收集到服务端，一个个轮询。有些连接只是建立，没有发数据，会出现空轮询。</p><h6 id="dma控制器" tabindex="-1"><a class="header-anchor" href="#dma控制器" aria-hidden="true">#</a> DMA控制器</h6><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>####### select bitmap</p><p>1024位大小</p><p>####### poll 结构体</p><p>大小不限</p><h5 id="epoll" tabindex="-1"><a class="header-anchor" href="#epoll" aria-hidden="true">#</a> epoll</h5><p>基于事件驱动</p><p>epoll_create：创建selector epoll_ctl：把事件注册进来 epoll_wait：监听事件（有返回值，为事件的个数）</p><p>分配一个内存块，创建一个事件收集器selector，注册所有的事件，selector会返回一个事件数组，由redis进行处理；如果没数据，selector处于阻塞状态。</p><h2 id="_5种基础数据结构" tabindex="-1"><a class="header-anchor" href="#_5种基础数据结构" aria-hidden="true">#</a> 5种基础数据结构</h2><h3 id="整体存储结构-全局哈希表" tabindex="-1"><a class="header-anchor" href="#整体存储结构-全局哈希表" aria-hidden="true">#</a> 整体存储结构：全局哈希表</h3><p>key：都是唯一的，都是字符串</p><p>value：不同数据结构的差异体现在此</p><h3 id="_5种" tabindex="-1"><a class="header-anchor" href="#_5种" aria-hidden="true">#</a> 5种</h3><h4 id="string-字符串" tabindex="-1"><a class="header-anchor" href="#string-字符串" aria-hidden="true">#</a> string 字符串</h4><h5 id="用途" tabindex="-1"><a class="header-anchor" href="#用途" aria-hidden="true">#</a> 用途</h5><p>缓存</p><p>分布式锁</p><h6 id="计数器" tabindex="-1"><a class="header-anchor" href="#计数器" aria-hidden="true">#</a> 计数器</h6><p>计数器生成分布式唯一ID</p><p>计数器统计网站访问量</p><h5 id="底层结构" tabindex="-1"><a class="header-anchor" href="#底层结构" aria-hidden="true">#</a> 底层结构</h5><h6 id="字符数组-类似java的arraylist" tabindex="-1"><a class="header-anchor" href="#字符数组-类似java的arraylist" aria-hidden="true">#</a> 字符数组（类似Java的ArrayList）</h6><p>动态字符串，是可以修改的字符串，采用预分配冗余空间的方式来减少内存的频繁分配</p><h5 id="命令" tabindex="-1"><a class="header-anchor" href="#命令" aria-hidden="true">#</a> 命令</h5><p>键值对：set/get/exists/del 批量键值对:mset/mget 设置过期时间:expire/setex 计数(value是整数):incr/incrby</p><h4 id="容器型数据结构" tabindex="-1"><a class="header-anchor" href="#容器型数据结构" aria-hidden="true">#</a> 容器型数据结构</h4><p>create if not exists / drop if no elements</p><h5 id="list-列表" tabindex="-1"><a class="header-anchor" href="#list-列表" aria-hidden="true">#</a> list 列表</h5><h6 id="用途-1" tabindex="-1"><a class="header-anchor" href="#用途-1" aria-hidden="true">#</a> 用途</h6><p>队列/消息队列/异步队列</p><p>####### 链表 微博关注人时间轴列表</p><h6 id="底层结构-1" tabindex="-1"><a class="header-anchor" href="#底层结构-1" aria-hidden="true">#</a> 底层结构</h6><p>双向链表（类似Java的LinkedList）</p><h6 id="命令-1" tabindex="-1"><a class="header-anchor" href="#命令-1" aria-hidden="true">#</a> 命令</h6><p>llen/lpop/rpush/rpop/lindex/lrange/ltrim</p><h5 id="hash-字典" tabindex="-1"><a class="header-anchor" href="#hash-字典" aria-hidden="true">#</a> hash 字典</h5><h6 id="用途-2" tabindex="-1"><a class="header-anchor" href="#用途-2" aria-hidden="true">#</a> 用途</h6><p>####### 用户信息 可以对每个字段单独存储，可以进行部分获取</p><h6 id="底层结构-2" tabindex="-1"><a class="header-anchor" href="#底层结构-2" aria-hidden="true">#</a> 底层结构</h6><p>&quot;数组+链表&quot;二维结构，采用渐进式rehash策略（类似Java的HashMap）</p><h6 id="value特点" tabindex="-1"><a class="header-anchor" href="#value特点" aria-hidden="true">#</a> value特点</h6><p>只能是字符串</p><h5 id="set-集合" tabindex="-1"><a class="header-anchor" href="#set-集合" aria-hidden="true">#</a> set 集合</h5><h6 id="用途-3" tabindex="-1"><a class="header-anchor" href="#用途-3" aria-hidden="true">#</a> 用途</h6><p>####### 去重集合 点赞</p><p>踩</p><p>共同好友</p><h6 id="底层结构-3" tabindex="-1"><a class="header-anchor" href="#底层结构-3" aria-hidden="true">#</a> 底层结构</h6><p>（类似Java的HashSet）</p><h6 id="value特点-1" tabindex="-1"><a class="header-anchor" href="#value特点-1" aria-hidden="true">#</a> value特点</h6><p>无序，唯一</p><h5 id="zset-有序集合" tabindex="-1"><a class="header-anchor" href="#zset-有序集合" aria-hidden="true">#</a> zset 有序集合</h5><h6 id="用途-4" tabindex="-1"><a class="header-anchor" href="#用途-4" aria-hidden="true">#</a> 用途</h6><p>排行榜</p><p>Redis最有特色的数据结构</p><h6 id="底层结构-4" tabindex="-1"><a class="header-anchor" href="#底层结构-4" aria-hidden="true">#</a> 底层结构</h6><p>####### 跳跃列表 跳表将有序链表改造为支持“折半查找”算法，类似于折半查找，可以进行快速的插入、删除、查找操作。 跳跃列表相当于在链表上建了索引层，每2个元素往上建一个索引层。 以空间换时间，空间多了1倍多，但性能明显变好</p><p>查找：eg查32，先在第1层找在25-100范围内，在第二层找在25-50范围内，在第三层找到32</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="value特点-2" tabindex="-1"><a class="header-anchor" href="#value特点-2" aria-hidden="true">#</a> value特点</h6><p>有序，唯一</p><h2 id="持久化机制" tabindex="-1"><a class="header-anchor" href="#持久化机制" aria-hidden="true">#</a> 持久化机制</h2><p>what：内存写入磁盘</p><p>why：内存数据库，在内存中操作，所以速度相当快，但仅在内存中，宕机时数据会丢失，所以需要持久化</p><h3 id="how" tabindex="-1"><a class="header-anchor" href="#how" aria-hidden="true">#</a> how</h3><h4 id="rdb-全量数据的快照" tabindex="-1"><a class="header-anchor" href="#rdb-全量数据的快照" aria-hidden="true">#</a> RDB 全量数据的快照</h4><h5 id="文件" tabindex="-1"><a class="header-anchor" href="#文件" aria-hidden="true">#</a> 文件</h5><p>dump.rdb</p><p>文件位置和AOF一致，均是在redis.conf里配置的dir的路径，自己配置要写绝对路径</p><h5 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h5><p>fork一个子进程（与主进程一模一样），先将数据写入临时文件，再用临时文件替换旧的持久化文件。 Note:fork系统调用用于创建一个新进程，称为子进程，可以理解为fork子进程即创建子进程。</p><p>RDB持久化，为什么要fork子进程？ 异步持久化，不会阻塞主进程（redis是单线程的），确保高性能</p><h5 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h5><p>会fork子进程 启动redis时，从磁盘加载持久化数据非常快 有可能会丢失最后一次之后写入的数据 不安全，性能好</p><h5 id="触发机制-4项" tabindex="-1"><a class="header-anchor" href="#触发机制-4项" aria-hidden="true">#</a> 触发机制（4项）</h5><p>1.shutdown时（关机时），如果没有开启AOF，会触发</p><h6 id="_2-配置文件中默认的快照配置-匹配任意一项就会触发" tabindex="-1"><a class="header-anchor" href="#_2-配置文件中默认的快照配置-匹配任意一项就会触发" aria-hidden="true">#</a> 2.配置文件中默认的快照配置，匹配任意一项就会触发</h6><p>#指定在多长时间内，有多少次更新操作，就执行RDB save 900 1 #900秒（15分钟）内有1个更改 save 300 100 #300秒（5分钟）内有100个更改 save 60 10000 #60秒内有10000个更改 #如果想禁用RDB持久化策略，只要不设置任何save命令，或给save传入一个空字符串参数也可以 save &quot;&quot;</p><p>3.执行命令save或bgsave save：使用主进程进行快照操作，全部阻塞（同步方式） bgsave：使用子进程后台异步进行快照操作，同时可以响应客户端的请求（异步方式） Note：其他方式触发的实际上也是调用了bgsave命令</p><p>4.执行flushall命令 清空内存，写入磁盘</p><h4 id="aof-追加日志" tabindex="-1"><a class="header-anchor" href="#aof-追加日志" aria-hidden="true">#</a> AOF 追加日志</h4><h5 id="文件-1" tabindex="-1"><a class="header-anchor" href="#文件-1" aria-hidden="true">#</a> 文件</h5><p>appendonly.aof</p><p>文件位置和RDB一致，均是在redis.conf里配置的dir的路径，自己配置要写绝对路径</p><h5 id="原理-1" tabindex="-1"><a class="header-anchor" href="#原理-1" aria-hidden="true">#</a> 原理</h5><p>以日志追加方式写入文件，读操作不记录 AOF由主进程处理，只要开启AOF，就会有个缓冲区（默认1M，可配置），主进程接到命令，把命令写入缓冲区，有定时任务从缓冲区写到磁盘。</p><h5 id="区别-1" tabindex="-1"><a class="header-anchor" href="#区别-1" aria-hidden="true">#</a> 区别</h5><p>AOF不会fork子进程，AOF重写会fork子进程 启动redis时，从磁盘加载持久化数据没RDB快 最多丢失不会超过2秒的数据 安全，性能不好</p><h5 id="触发机制" tabindex="-1"><a class="header-anchor" href="#触发机制" aria-hidden="true">#</a> 触发机制</h5><p>可在配置文件里指定定时任务更新任务条件，如下三个可选值： no：缓冲区满了同步（效率快，不安全） always：每次变更同步（效率慢，安全） everysec：每秒同步（默认值，折中方案，很快，但可能丢失1秒内的数据）</p><p>同步策略（每秒同步，每修改同步，不同步）</p><h5 id="为什么会出现aof" tabindex="-1"><a class="header-anchor" href="#为什么会出现aof" aria-hidden="true">#</a> 为什么会出现AOF</h5><p>解决RDB丢失数据太多的问题（临时宕机，1，3，4不会触发RDB，且在没有匹配到2触发RDB的情况下，2中配置的间隔时间内的数据均会丢失） RDB的save 1 1 和AOF默认每秒同步，有区别吗？ 有区别，RDB太频繁，每次fork子进程，影响性能</p><h5 id="aof的重写" tabindex="-1"><a class="header-anchor" href="#aof的重写" aria-hidden="true">#</a> AOF的重写</h5><p>目的：减少AOF文件的体积 fork一个子进程，rewrite会去掉过程性操作，进行压缩，用rdb存储重写后的结果，更节约空间 redis4.0之后有了混合持久化，是对重写的进一步优化</p><h5 id="开启aof" tabindex="-1"><a class="header-anchor" href="#开启aof" aria-hidden="true">#</a> 开启AOF</h5><p>#redis.conf配置文件 appendonly yes</p><h3 id="性能建议" tabindex="-1"><a class="header-anchor" href="#性能建议" aria-hidden="true">#</a> 性能建议</h3><h4 id="_1-两种持久化机制同时开启。如果两个同时开启-优先使用aof持久化机制" tabindex="-1"><a class="header-anchor" href="#_1-两种持久化机制同时开启。如果两个同时开启-优先使用aof持久化机制" aria-hidden="true">#</a> 1.两种持久化机制同时开启。如果两个同时开启，优先使用AOF持久化机制</h4><p>2.需要fork子进程的尽量减少频率 因为RDB文件只用作备份恢复，只要15分钟备份一次就够了，只保留save 900 1这条规则。 只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G。</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="过期键删除策略" tabindex="-1"><a class="header-anchor" href="#过期键删除策略" aria-hidden="true">#</a> 过期键删除策略</h2><p>Redis同时使用了惰性过期和定期过期两种过期策略</p><h3 id="策略" tabindex="-1"><a class="header-anchor" href="#策略" aria-hidden="true">#</a> 策略</h3><h4 id="惰性过期" tabindex="-1"><a class="header-anchor" href="#惰性过期" aria-hidden="true">#</a> 惰性过期</h4><p>访问时才判断key是否过期</p><p>内存不友好，CPU友好</p><h4 id="定期过期" tabindex="-1"><a class="header-anchor" href="#定期过期" aria-hidden="true">#</a> 定期过期</h4><p>每隔一段时间扫描一定数量的key</p><p>折中</p><h4 id="定时过期" tabindex="-1"><a class="header-anchor" href="#定时过期" aria-hidden="true">#</a> 定时过期</h4><p>定时器，一到时间，实时删除key</p><p>内存友好，CPU不友好</p><h2 id="内存淘汰机制-逐出算法" tabindex="-1"><a class="header-anchor" href="#内存淘汰机制-逐出算法" aria-hidden="true">#</a> 内存淘汰机制（逐出算法）</h2><p>当内存不足以容纳新写入数据时,触发内存淘汰机制</p><h3 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h3><p>noeviction：报错</p><h4 id="键空间中" tabindex="-1"><a class="header-anchor" href="#键空间中" aria-hidden="true">#</a> 键空间中</h4><p>allkeys-lru：键空间中，移除最近最少使用key</p><p>allkeys-random：键空间中，移除随机key</p><h4 id="设置了过期时间的键空间中" tabindex="-1"><a class="header-anchor" href="#设置了过期时间的键空间中" aria-hidden="true">#</a> 设置了过期时间的键空间中</h4><p>volatile-lru：设置了过期时间的键空间中，移除最近最少使用key</p><p>volatile-random：设置了过期时间的键空间中，移除随机key</p><p>volatile-ttl：设置了过期时间的键空间中，移除更早过期key</p><h2 id="集群方案" tabindex="-1"><a class="header-anchor" href="#集群方案" aria-hidden="true">#</a> 集群方案</h2><p>演变：单机版--&gt;Redis主从复制--&gt;Redis哨兵模式--&gt;Redis Cluster</p><h3 id="方案" tabindex="-1"><a class="header-anchor" href="#方案" aria-hidden="true">#</a> 方案</h3><h4 id="单机版" tabindex="-1"><a class="header-anchor" href="#单机版" aria-hidden="true">#</a> 单机版</h4><p>核心技术：持久化</p><p>持久化是最简单的高可用方法（有时甚至不被归为高可用手段）</p><h4 id="redis主从复制" tabindex="-1"><a class="header-anchor" href="#redis主从复制" aria-hidden="true">#</a> Redis主从复制</h4><p>复制是高可用Redis的基础。实现了多机备份，读操作负载均衡，简单的故障恢复，读写分离，提高吞吐量</p><p>缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制</p><h4 id="redis哨兵模式" tabindex="-1"><a class="header-anchor" href="#redis哨兵模式" aria-hidden="true">#</a> Redis哨兵模式</h4><p>哨兵实现自动化的故障恢复</p><p>缺陷：写操作无法负载均衡；存储能力受到单机的限制</p><p>基于主从模式，自动故障迁移 哨兵机制选举大会 角色：1主节点2从节点3哨兵（Note:哨兵必为奇数个） 主从节点向哨兵发送心跳。 一个哨兵收不到主节点的心跳，主观下线 两个哨兵收不到主节点的心跳，客观下线 3个哨兵中选1个leader，有半数以上(2票)就是leader 由leader决定哪个从节点当主节点，然后进行故障迁移</p><h4 id="redis-cluster" tabindex="-1"><a class="header-anchor" href="#redis-cluster" aria-hidden="true">#</a> Redis Cluster</h4><p>解决了写操作无法负载均衡和存储能力受到单机的限制的问题，实现了较为完善的高可用方案</p><p>有多个主从模式（至少3个主节点）组成的大集群，故障迁移时不需要依赖哨兵，但有哨兵的功能，从节点可自动切换为主节点</p><p>通过把key哈希取模映射到16384个槽位（Note:16384=16*1024是redis写死的一个数），这16384个槽位被集群中主节点划分（即多个主节点瓜分16384个槽位，可以按区间，也可间插着分），进而定位到其中一个主节点（Note：槽位不是用来存数据的，只是用来分片的）</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>redis官方客户端才有重定向功能，jedis没有重定向功能</p><p>Redis Cluster：服务端做分片 Redis Sharding：客户端做分片</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="主从复制-全量复制-增量复制" tabindex="-1"><a class="header-anchor" href="#主从复制-全量复制-增量复制" aria-hidden="true">#</a> 主从复制（全量复制&amp;增量复制）</h2><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： 　　1）从服务器连接主服务器，发送SYNC命令； 　　2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； 　　3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 　　6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</p><p>什么时候需复制？（选择：看从节点复制了多少） 1）从服务器掉线重连（增量复制） 2）新增节点（全量复制） 3）主服务器id变了（全量复制） 4）复制偏移量&lt;积压缓冲区（增量复制） 5）复制偏移量&gt;积压缓冲区（全量复制）</p><p>数据的一致性问题：同步复制与异步复制</p><h2 id="事务实现" tabindex="-1"><a class="header-anchor" href="#事务实现" aria-hidden="true">#</a> 事务实现</h2><p>对事务的支持ACID ：watch命令</p><p>Redis使用WATCH命令来决定事务是继续执行还是回滚，那就需要在MULTI之前使用WATCH来监控某些键值对，然后使用MULTI命令来开启事务，执行对数据结构操作的各种命令，此时这些命令入队列。 当使用EXEC执行事务时，首先会比对WATCH所监控的键值对，如果没发生改变，它会执行事务队列中的命令，提交事务；如果发生变化，将不会执行事务中的任何命令，同时事务回滚。当然无论是否回滚，Redis都会取消执行事务前的WATCH命令。</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="缓存雪崩、缓存穿透与缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存雪崩、缓存穿透与缓存击穿" aria-hidden="true">#</a> 缓存雪崩、缓存穿透与缓存击穿</h2><h3 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩" aria-hidden="true">#</a> 缓存雪崩</h3><h4 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h4><p>大量的Redis缓存在同一时间全部失效，导致大量请求全打到数据库，导致数据库挂掉</p><h4 id="解决" tabindex="-1"><a class="header-anchor" href="#解决" aria-hidden="true">#</a> 解决</h4><p>随机设置过期时间 定时任务，失效前重置过期时间 集群部署，热点key分布在不同节点上</p><h3 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿" aria-hidden="true">#</a> 缓存击穿</h3><h4 id="概念-1" tabindex="-1"><a class="header-anchor" href="#概念-1" aria-hidden="true">#</a> 概念</h4><p>一个热点key的缓存失效，一瞬间大量请求打到数据库上，导致数据库挂掉</p><h4 id="解决-1" tabindex="-1"><a class="header-anchor" href="#解决-1" aria-hidden="true">#</a> 解决</h4><p>设置热点key永不过期 使用分布式锁（单体使用互斥锁）</p><h3 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透" aria-hidden="true">#</a> 缓存穿透</h3><h4 id="概念-2" tabindex="-1"><a class="header-anchor" href="#概念-2" aria-hidden="true">#</a> 概念</h4><p>常见于黑客攻击缓存和数据库都没有的数据，导致数据库挂掉，eg.请求id为-1的数据</p><h4 id="解决-2" tabindex="-1"><a class="header-anchor" href="#解决-2" aria-hidden="true">#</a> 解决</h4><p>对参数进行校验 使用布隆过滤器 就算数据库查出为空，也缓存到redis里（可能换参数） 把ip拉黑（可能换ip）</p><h5 id="布隆过滤器" tabindex="-1"><a class="header-anchor" href="#布隆过滤器" aria-hidden="true">#</a> 布隆过滤器</h5><p>底层是二进制数组，多个哈希函数映射到数组上，都是1可能存在，有0则一定不存在 增和查是一样的原理，删除不好删 优：占空间小；速度快，O(k)，k为哈希函数个数（按hash算出来的值找下标）；保密性安全性好 缺：很难删除；存在误判，只能减小误判的概率 参数误判率设置越小，需要的哈希函数也就越多，计算时间越长，性能越差，不能设置太小。</p><h2 id="如何保证redis和mysql数据一致" tabindex="-1"><a class="header-anchor" href="#如何保证redis和mysql数据一致" aria-hidden="true">#</a> 如何保证Redis和Mysql数据一致</h2><h3 id="一致性分类" tabindex="-1"><a class="header-anchor" href="#一致性分类" aria-hidden="true">#</a> 一致性分类</h3><h4 id="强一致性-加分布式锁或读写锁" tabindex="-1"><a class="header-anchor" href="#强一致性-加分布式锁或读写锁" aria-hidden="true">#</a> 强一致性：加分布式锁或读写锁</h4><p>加分布式锁，更新mysql，同时更新或删除redis缓存，保证期间不会有其他线程进入</p><p>加读写锁，写-写与读-写互斥，读-读不互斥，保证一个线程写时，其他线程不会进入</p><p>最终一致性：定时任务同步；mq异步发消息。</p><h3 id="不一致的场景" tabindex="-1"><a class="header-anchor" href="#不一致的场景" aria-hidden="true">#</a> 不一致的场景</h3><h4 id="_1-先更新数据库-再更新缓存-但缓存更新失败。缓存中是旧数据。" tabindex="-1"><a class="header-anchor" href="#_1-先更新数据库-再更新缓存-但缓存更新失败。缓存中是旧数据。" aria-hidden="true">#</a> 1.先更新数据库，再更新缓存，但缓存更新失败。缓存中是旧数据。</h4><p>2.先更新数据库，再更新缓存。A,B线程先后进行更新操作，顺序为：线程A更新数据库，线程B更新数据库， 线程B更新缓存，线程A更新缓存。缓存中是旧数据。 Note：一般选删除缓存（等下次用到了从数据库取），而不是更新缓存</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_3-先删除缓存-再修改数据库。a线程进行更新操作-b线程进行查询操作-顺序为-线程a删除缓存-线程b查询缓存为空-线程b查数据库加入缓存-线程a更新数据库。缓存中是旧数据。" tabindex="-1"><a class="header-anchor" href="#_3-先删除缓存-再修改数据库。a线程进行更新操作-b线程进行查询操作-顺序为-线程a删除缓存-线程b查询缓存为空-线程b查数据库加入缓存-线程a更新数据库。缓存中是旧数据。" aria-hidden="true">#</a> 3.先删除缓存，再修改数据库。A线程进行更新操作，B线程进行查询操作，顺序为：线程A删除缓存，线程B查询缓存为空，线程B查数据库加入缓存，线程A更新数据库。缓存中是旧数据。</h4><p>4.先修改数据库，再删除缓存。线程1更新数据库并删除缓存，线程3查缓存为空进而查数据库，线程2更新数据库并删除缓存，线程3更新缓存。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h3><h4 id="延时双删" tabindex="-1"><a class="header-anchor" href="#延时双删" aria-hidden="true">#</a> 延时双删</h4><p>在更新数据库前后均执行删除缓存操作（或两次删除都在更新数据库之后），第二次是在更新数据库之后sleep(50秒)再删除缓存</p><p>这种方案能解决一部分问题，但不能彻底解决，而且让写请求sleep一段时间，使得写请求吞吐量下降</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="内存队列" tabindex="-1"><a class="header-anchor" href="#内存队列" aria-hidden="true">#</a> 内存队列</h4><p>原理就是同一个key的增删改查都放到一个队列里依次执行（类似于RocketMQ顺序队列的实现）</p><p>实现起来比较繁杂，而且容易出问题</p><h4 id="读写锁" tabindex="-1"><a class="header-anchor" href="#读写锁" aria-hidden="true">#</a> 读写锁</h4><p>（Redisson里的读写锁）</p><p>能解决读多写少的场景，80%都会是读多写少</p><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h2><p>安装</p><p>配置文件解析（要想性能调优，就要了解redis.conf里的主要配置）</p><p>持久化</p><p>删除策略</p><p>事务</p><p>发布订阅</p><p>java客户端操作（jedis）</p>',225),x=[b];function g(_,k){return e(),r("div",null,x)}const y=a(u,[["render",g],["__file","redis.html.vue"]]);export{y as default};
