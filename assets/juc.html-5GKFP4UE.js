const e=JSON.parse('{"key":"v-0bbbc80c","path":"/java/juc/juc.html","title":"并发","lang":"en-US","frontmatter":{"icon":"lightbulb","description":"并发 基础 并发 并发与并行 并行：单位时间内，多个任务同时执行 并发：同一时间段，多个任务都在执行 (单位时间内不一定同时执行) 进程、线程与并发 进程让操作系统的并发性成为了可能 CPU采用时间片轮转方式运行进程 CPU为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且CPU分配给另一个进程（这个过程叫做上下文切换）。如果进程在时间片结束前阻塞或结束，则CPU立即进行切换，不用等待时间片用完。","head":[["meta",{"property":"og:url","content":"https://liz-in-tech.github.io/pinkpig/java/juc/juc.html"}],["meta",{"property":"og:site_name","content":"Liz"}],["meta",{"property":"og:title","content":"并发"}],["meta",{"property":"og:description","content":"并发 基础 并发 并发与并行 并行：单位时间内，多个任务同时执行 并发：同一时间段，多个任务都在执行 (单位时间内不一定同时执行) 进程、线程与并发 进程让操作系统的并发性成为了可能 CPU采用时间片轮转方式运行进程 CPU为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且CPU分配给另一个进程（这个过程叫做上下文切换）。如果进程在时间片结束前阻塞或结束，则CPU立即进行切换，不用等待时间片用完。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-02-16T13:11:34.000Z"}],["meta",{"property":"article:author","content":"Liz"}],["meta",{"property":"article:modified_time","content":"2025-02-16T13:11:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并发\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-16T13:11:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Liz\\",\\"url\\":\\"https://github.com/liz-in-tech\\"}]}"]]},"headers":[{"level":2,"title":"基础","slug":"基础","link":"#基础","children":[{"level":3,"title":"并发","slug":"并发-1","link":"#并发-1","children":[]},{"level":3,"title":"程序、进程、线程","slug":"程序、进程、线程","link":"#程序、进程、线程","children":[]},{"level":3,"title":"线程","slug":"线程-1","link":"#线程-1","children":[]},{"level":3,"title":"sleep()与wait()","slug":"sleep-与wait","link":"#sleep-与wait","children":[]}]},{"level":2,"title":"线程和线程池","slug":"线程和线程池","link":"#线程和线程池","children":[{"level":3,"title":"Thread类","slug":"thread类","link":"#thread类","children":[]},{"level":3,"title":"线程池与","slug":"线程池与","link":"#线程池与","children":[]}]},{"level":2,"title":"线程内存模型/","slug":"线程内存模型","link":"#线程内存模型","children":[{"level":3,"title":"JMM与Java内存区域划分的区别与联系","slug":"jmm与java内存区域划分的区别与联系","link":"#jmm与java内存区域划分的区别与联系","children":[]},{"level":3,"title":"线程共享：主内存","slug":"线程共享-主内存","link":"#线程共享-主内存","children":[]},{"level":3,"title":"JMM控制的规则","slug":"jmm控制的规则","link":"#jmm控制的规则","children":[]},{"level":3,"title":"指令重排与happens-before","slug":"指令重排与happens-before","link":"#指令重排与happens-before","children":[]}]},{"level":2,"title":"并发编程的三个重要特征/线程内存模型的三大特性","slug":"并发编程的三个重要特征-线程内存模型的三大特性","link":"#并发编程的三个重要特征-线程内存模型的三大特性","children":[{"level":3,"title":"细节","slug":"细节-2","link":"#细节-2","children":[]}]},{"level":2,"title":"并发编程的关键问题","slug":"并发编程的关键问题","link":"#并发编程的关键问题","children":[{"level":3,"title":"两个关键问题","slug":"两个关键问题","link":"#两个关键问题","children":[]},{"level":3,"title":"线程通信","slug":"线程通信","link":"#线程通信","children":[]}]},{"level":2,"title":"volatile关键字","slug":"volatile关键字","link":"#volatile关键字","children":[{"level":3,"title":"用法","slug":"用法","link":"#用法","children":[]},{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":3,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]},{"level":3,"title":"功能","slug":"功能","link":"#功能","children":[]}]},{"level":2,"title":"synchronized与ReentrantLock","slug":"synchronized与reentrantlock","link":"#synchronized与reentrantlock","children":[{"level":3,"title":"synchronized与ReentrantLock的区别与联系","slug":"synchronized与reentrantlock的区别与联系","link":"#synchronized与reentrantlock的区别与联系","children":[]},{"level":3,"title":"synchronized和volatile的区别","slug":"synchronized和volatile的区别","link":"#synchronized和volatile的区别","children":[]},{"level":3,"title":"synchronized关键字","slug":"synchronized关键字","link":"#synchronized关键字","children":[]},{"level":3,"title":"ReentrantLock类","slug":"reentrantlock类","link":"#reentrantlock类","children":[]}]},{"level":2,"title":"JUC","slug":"juc","link":"#juc","children":[{"level":3,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":3,"title":"","slug":"-6","link":"#-6","children":[]},{"level":3,"title":"构成","slug":"构成","link":"#构成","children":[]}]}],"git":{"createdTime":1730220137000,"updatedTime":1739711494000,"contributors":[{"name":"liz","email":"liz@MacBook-Pro.local","commits":2},{"name":"unknown","email":"15721607377@163.com","commits":1}]},"readingTime":{"minutes":62.96,"words":18888},"filePathRelative":"java/juc/juc.md","localizedDate":"October 29, 2024","excerpt":"<h1> 并发</h1>\\n<h2> 基础</h2>\\n<h3> 并发</h3>\\n<h4> 并发与并行</h4>\\n<p>并行：单位时间内，多个任务同时执行</p>\\n<p>并发：同一时间段，多个任务都在执行 (单位时间内不一定同时执行)</p>\\n<h4> 进程、线程与并发</h4>\\n<h5> 进程让操作系统的并发性成为了可能</h5>\\n<h6> CPU采用时间片轮转方式运行进程</h6>\\n<p>CPU为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且CPU分配给另一个进程（这个过程叫做上下文切换）。如果进程在时间片结束前阻塞或结束，则CPU立即进行切换，不用等待时间片用完。</p>","autoDesc":true}');export{e as data};
