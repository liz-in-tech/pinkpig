import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c as r,e as n}from"./app-dh4YKh5Y.js";const p="/pinkpig/assets/jvm_001-23csEfPe.png",d="/pinkpig/assets/jvm_002-tc-APl22.png",h="/pinkpig/assets/jvm_003-Li7ZT0OP.png",t="/pinkpig/assets/jvm_004-byehlgXq.png",s="/pinkpig/assets/jvm_005-CvygPLAk.png",o="/pinkpig/assets/jvm_006-y9d8hMfG.png",c="/pinkpig/assets/jvm_007-fp66yIEd.png",l="/pinkpig/assets/jvm_008-1_Ufdpln.png",g="/pinkpig/assets/jvm_009-fsk0Xhkq.png",f="/pinkpig/assets/jvm_010-BMwGUqM9.png",a="/pinkpig/assets/jvm_011-k2dbtuHb.png",u="/pinkpig/assets/jvm_012-DfFBentZ.png",m="/pinkpig/assets/jvm_013-ToDWMVIO.png",b="/pinkpig/assets/jvm_014-OQJf3eiW.png",x="/pinkpig/assets/jvm_015-oHs92TyQ.png",v="/pinkpig/assets/jvm_016-Z9Zp9Vji.png",_="/pinkpig/assets/jvm_017-2RRUnBaC.png",C="/pinkpig/assets/jvm_018-off4SlhO.png",S="/pinkpig/assets/jvm_019-sdtSNkwG.png",j="/pinkpig/assets/jvm_020-NdyjlLrw.png",M="/pinkpig/assets/jvm_021-w6BrLpoQ.png",J="/pinkpig/assets/jvm_022-Y7QcJpBS.png",k="/pinkpig/assets/jvm_023-zf2MIi2t.png",y="/pinkpig/assets/jvm_024-ggePY4U8.png",G="/pinkpig/assets/jvm_025-zkg19S6_.png",z="/pinkpig/assets/jvm_026-ZWG7Ao3o.png",P="/pinkpig/assets/jvm_027-ZiLvDCBC.png",X="/pinkpig/assets/jvm_028-a8kb212d.png",T="/pinkpig/assets/jvm_029-XQeqPWGH.png",R="/pinkpig/assets/jvm_030-dsFdMjWm.png",V="/pinkpig/assets/jvm_031-YSCV10br.png",E="/pinkpig/assets/jvm_032-M6iPTYvw.png",O="/pinkpig/assets/jvm_033-jbE3SZMB.png",w="/pinkpig/assets/jvm_034-Mzj0oJa7.png",F="/pinkpig/assets/jvm_035-EXKrpjEK.png",A="/pinkpig/assets/jvm_036-GdJd3-Pn.png",B="/pinkpig/assets/jvm_037-oO0gMXFI.png",L="/pinkpig/assets/jvm_038-WirS90WT.png",D="/pinkpig/assets/jvm_039-a-M5j0WX.png",q="/pinkpig/assets/jvm_040-j8fG6Pzv.png",N="/pinkpig/assets/jvm_041-0hBISfmp.png",U="/pinkpig/assets/jvm_042-jQyRUx9D.png",H="/pinkpig/assets/jvm_043-bNWdSK4x.png",K="/pinkpig/assets/jvm_044-1nFlWXVq.png",W="/pinkpig/assets/jvm_045-KiEUOwb-.png",I="/pinkpig/assets/jvm_046-jzByKoim.png",Q="/pinkpig/assets/jvm_047-LWDFoA2B.png",Z="/pinkpig/assets/jvm_048-7tdmCQyR.png",Y="/pinkpig/assets/jvm_049-L55yhEI3.png",$="/pinkpig/assets/jvm_050-wx1wiQAs.png",aa="/pinkpig/assets/jvm_051-3YM-rXOj.png",ea="/pinkpig/assets/jvm_052-5ha3NPkE.png",ia="/pinkpig/assets/jvm_053-Hq-slqd3.png",ra="/pinkpig/assets/jvm_054-V-bC-iFH.png",na="/pinkpig/assets/jvm_055-PPnVfwi8.png",pa={},da=n('<h1 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> JVM</h1><h2 id="_1、概述" tabindex="-1"><a class="header-anchor" href="#_1、概述" aria-hidden="true">#</a> 1、概述</h2><h3 id="java技术体系" tabindex="-1"><a class="header-anchor" href="#java技术体系" aria-hidden="true">#</a> Java技术体系</h3><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h4><h5 id="平台无关性-语言无关性" tabindex="-1"><a class="header-anchor" href="#平台无关性-语言无关性" aria-hidden="true">#</a> 平台无关性&amp;语言无关性</h5><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="平台无关性" tabindex="-1"><a class="header-anchor" href="#平台无关性" aria-hidden="true">#</a> 平台无关性</h6><p>一次编译，到处运行</p><p>各硬件平台有针对性的JVM，可以将同一份字节码文件解释为对应平台的机器码</p><h6 id="语言无关性" tabindex="-1"><a class="header-anchor" href="#语言无关性" aria-hidden="true">#</a> 语言无关性</h6><p>任何能编译成字节码文件的语言，都能被JVM运行。JVM 只认识 .class 文件，它不关心是何种语言生成了 .class 文件，只要 .class 文件符合 JVM 的规范就能运行。 目前已经有 JRuby、Jython、Scala 等语言能够在 JVM 上运行。它们有各自的语法规则，不过它们的编译器都能将各自的源码编译成符合 JVM 规范的 .class 文件，从而能够借助 JVM 运行它们。</p><p>Java 语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的， 因此字节码命令所能提供的语义描述能力肯定会比 Java 语言本身更加强大。 因此，有一些 Java 语言本身无法有效支持的语言特性，不代表字节码本身无法有效支 持。</p><h6 id="为什么说-java-语言-编译与解释并存" tabindex="-1"><a class="header-anchor" href="#为什么说-java-语言-编译与解释并存" aria-hidden="true">#</a> 为什么说 Java 语言“编译与解释并存”？</h6><p>####### <img src="'+d+'" alt="" loading="lazy"></p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="自动化内存管理" tabindex="-1"><a class="header-anchor" href="#自动化内存管理" aria-hidden="true">#</a> 自动化内存管理</h5><h6 id="内存自动分配与内存回收-垃圾收集-技术" tabindex="-1"><a class="header-anchor" href="#内存自动分配与内存回收-垃圾收集-技术" aria-hidden="true">#</a> 内存自动分配与内存回收（垃圾收集）技术</h6><p>避免了绝大部分内存泄漏和指针越界问题</p><h5 id="热点代码检测和运行时编译及优化" tabindex="-1"><a class="header-anchor" href="#热点代码检测和运行时编译及优化" aria-hidden="true">#</a> 热点代码检测和运行时编译及优化</h5><p>运行时间增长可获得更高性能</p><h5 id="完善的应用程序接口" tabindex="-1"><a class="header-anchor" href="#完善的应用程序接口" aria-hidden="true">#</a> 完善的应用程序接口</h5><p>丰富的第三方类库</p><h4 id="组成" tabindex="-1"><a class="header-anchor" href="#组成" aria-hidden="true">#</a> 组成</h4><h5 id="编程语言" tabindex="-1"><a class="header-anchor" href="#编程语言" aria-hidden="true">#</a> 编程语言</h5><p>狭义：Java</p><p>广义：Java、Kotlin、Scala、Clojure、JRuby、Groovy等可运行于JVM上的编程语言</p><p>各硬件平台的JVM实现</p><p>Class文件格式</p><p>Java类库API</p><p>第三方类库</p><h3 id="jdk、jre、jvm" tabindex="-1"><a class="header-anchor" href="#jdk、jre、jvm" aria-hidden="true">#</a> JDK、JRE、JVM</h3><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="java发展史" tabindex="-1"><a class="header-anchor" href="#java发展史" aria-hidden="true">#</a> Java发展史</h3><p>发布 1995年</p><p>Java SE 8(LTS) 2014年3月</p><p>Java SE 11(LTS) 2018年9月</p><p>Java SE 17(LTS) 2021年9月</p><p>Java SE 21(LTS) 2023年9月</p><h3 id="java虚拟机" tabindex="-1"><a class="header-anchor" href="#java虚拟机" aria-hidden="true">#</a> Java虚拟机</h3><h4 id="标准规范" tabindex="-1"><a class="header-anchor" href="#标准规范" aria-hidden="true">#</a> 标准规范</h4><p>JVM有多种实现版本，都要遵循统一的标准规范</p><h4 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h4><h5 id="hotspot虚拟机" tabindex="-1"><a class="header-anchor" href="#hotspot虚拟机" aria-hidden="true">#</a> HotSpot虚拟机</h5><p>使用范围最广的JVM</p><p>HotSpot，顾名思义，是基于热点代码探测的，有JIT即时编译功能，能提供更高质量的本地代码</p><h4 id="jvm体系架构" tabindex="-1"><a class="header-anchor" href="#jvm体系架构" aria-hidden="true">#</a> JVM体系架构</h4><p>HotSpot JVM Architecture 主要包括3个组件</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+o+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="类装载子系统-class-loader-subsystem" tabindex="-1"><a class="header-anchor" href="#类装载子系统-class-loader-subsystem" aria-hidden="true">#</a> 类装载子系统 Class Loader Subsystem</h5><p>类加载过程</p><p>类加载器</p><h5 id="运行时数据区-runtime-data-areas" tabindex="-1"><a class="header-anchor" href="#运行时数据区-runtime-data-areas" aria-hidden="true">#</a> 运行时数据区 Runtime Data Areas</h5><p>内存模型</p><h5 id="字节码执行引擎-execution-engine" tabindex="-1"><a class="header-anchor" href="#字节码执行引擎-execution-engine" aria-hidden="true">#</a> 字节码执行引擎 Execution Engine</h5><h6 id="interpreter-解释器" tabindex="-1"><a class="header-anchor" href="#interpreter-解释器" aria-hidden="true">#</a> Interpreter 解释器</h6><p>顺序读取并执行字节码指令</p><h6 id="jit-just-in-time-compiler-即时编译" tabindex="-1"><a class="header-anchor" href="#jit-just-in-time-compiler-即时编译" aria-hidden="true">#</a> JIT (Just In Time Compiler) 即时编译</h6><p>抵消了Interpreter执行速度慢的缺点并提高了性能。 JIT编译器同时编译字节码的类似部分（热点代码），从而减少了编译所需的总时间。</p><h6 id="gc-garbage-collection" tabindex="-1"><a class="header-anchor" href="#gc-garbage-collection" aria-hidden="true">#</a> GC（Garbage Collection）</h6><p>引用分类</p><p>判断对象是否存活</p><p>垃圾收集算法</p><p>垃圾收集器</p><p>JVM性能调优</p><h2 id="_2、类加载机制" tabindex="-1"><a class="header-anchor" href="#_2、类加载机制" aria-hidden="true">#</a> 2、类加载机制</h2><h3 id="class文件结构" tabindex="-1"><a class="header-anchor" href="#class文件结构" aria-hidden="true">#</a> Class文件结构</h3><p>Class 文件是二进制文件，它的内容具有严格的规范，文件中没有任何空格，全都是连续的0/1。Class 文件中的所有内容被分为两种类型：无符号数、表。</p><pre><code>   无符号数：无符号数表示 Class 文件中的值，这些值没有任何类型，但有不同的长度。u1、u2、u4、u8 分别代表 1/2/4/8 字节的无符号数。
   表：由多个无符号数或者其他表作为数据项构成的复合数据类型。
</code></pre><h4 id="构成" tabindex="-1"><a class="header-anchor" href="#构成" aria-hidden="true">#</a> 构成</h4><h5 id="魔数" tabindex="-1"><a class="header-anchor" href="#魔数" aria-hidden="true">#</a> 魔数</h5><p>1-4字节</p><p>表示Class文件类型</p><p>16 进制表示的“CAFE BABE”</p><h5 id="版本信息" tabindex="-1"><a class="header-anchor" href="#版本信息" aria-hidden="true">#</a> 版本信息</h5><h6 id="_5-8字节" tabindex="-1"><a class="header-anchor" href="#_5-8字节" aria-hidden="true">#</a> 5-8字节</h6><p>5-6 次版本号</p><p>7-8 主版本号</p><h6 id="表示jdk版本" tabindex="-1"><a class="header-anchor" href="#表示jdk版本" aria-hidden="true">#</a> 表示JDK版本</h6><p>高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，即使文 件格式并未发生任何变化，虚拟机也必需拒绝执行超过其版本号的 Class 文件</p><h5 id="常量池" tabindex="-1"><a class="header-anchor" href="#常量池" aria-hidden="true">#</a> 常量池</h5><h6 id="字面值常量" tabindex="-1"><a class="header-anchor" href="#字面值常量" aria-hidden="true">#</a> 字面值常量</h6><p>字面值常量就是我们在程序中定义的字符串、被 final 修饰的值</p><h6 id="符号引用" tabindex="-1"><a class="header-anchor" href="#符号引用" aria-hidden="true">#</a> 符号引用</h6><p>符号引用就是我们定义的各种名字：类和接口的全限定名、字段的名字和描述符、方法的名字和描述符</p><h5 id="访问标志" tabindex="-1"><a class="header-anchor" href="#访问标志" aria-hidden="true">#</a> 访问标志</h5><p>识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否被 abstract/final修饰</p><p>类索引、父类索引、接口索引集合</p><h5 id="字段表集合" tabindex="-1"><a class="header-anchor" href="#字段表集合" aria-hidden="true">#</a> 字段表集合</h5><p>存储本类涉及到的成员变量，包括实例变量和类变量，但不包括方法中的局部变量</p><p>方法表集合</p><h5 id="属性表集合" tabindex="-1"><a class="header-anchor" href="#属性表集合" aria-hidden="true">#</a> 属性表集合</h5><p>方法表的属性表集合中有一张 Code 属性表，用于存储当前方法经编译器编译后的字节码指令</p><h3 id="类加载过程-类的生命周期" tabindex="-1"><a class="header-anchor" href="#类加载过程-类的生命周期" aria-hidden="true">#</a> 类加载过程/类的生命周期</h3><p>类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。 JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。（JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。）</p><p>类加载过程包括5个阶段：加载、验证、准备、解析、初始化</p><p>类的生命周期包括7各阶段：类加载5个阶段、使用、卸载</p><p>验证、准备、解析3个阶段统称为连接</p><figure><img src="`+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_5个阶段" tabindex="-1"><a class="header-anchor" href="#_5个阶段" aria-hidden="true">#</a> 5个阶段</h4><h5 id="加载-把class字节码文件从各个来源通过类加载器装载入内存中" tabindex="-1"><a class="header-anchor" href="#加载-把class字节码文件从各个来源通过类加载器装载入内存中" aria-hidden="true">#</a> 加载：把class字节码文件从各个来源通过类加载器装载入内存中</h5><h6 id="加载-是-类加载-过程的一个阶段-不能混淆这两个名词。在加载阶段-虚拟机需要完成-3-件" tabindex="-1"><a class="header-anchor" href="#加载-是-类加载-过程的一个阶段-不能混淆这两个名词。在加载阶段-虚拟机需要完成-3-件" aria-hidden="true">#</a> “加载”是“类加载”过程的一个阶段，不能混淆这两个名词。在加载阶段，虚拟机需要完成 3 件</h6><p>事： 1、通过类的全限定名获取该类的二进制字节流。 2、将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。 3、在内存中（堆中）创建一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。 获取二进制字节流/字节码来源途径： 1、从 zip 包中读取，如 jar、war等 2、从网络中获取，如 Applet 3、通过动态代理技术生成代理类的二进制字节流 4、由 JSP 文件生成对应的 Class 类 5、从数据库中读取，如 有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在 集群间的分发。</p><h5 id="验证-主要是为了保证加载进来的字节流符合虚拟机规范-不会造成安全错误" tabindex="-1"><a class="header-anchor" href="#验证-主要是为了保证加载进来的字节流符合虚拟机规范-不会造成安全错误" aria-hidden="true">#</a> 验证：主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误</h5><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="文件格式验证" tabindex="-1"><a class="header-anchor" href="#文件格式验证" aria-hidden="true">#</a> 文件格式验证</h6><p>验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理</p><p>比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p><h6 id="元数据验证" tabindex="-1"><a class="header-anchor" href="#元数据验证" aria-hidden="true">#</a> 元数据验证</h6><p>比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p><h6 id="字节码验证" tabindex="-1"><a class="header-anchor" href="#字节码验证" aria-hidden="true">#</a> 字节码验证</h6><p>本阶段是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。</p><h6 id="符号引用验证" tabindex="-1"><a class="header-anchor" href="#符号引用验证" aria-hidden="true">#</a> 符号引用验证</h6><p>比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p><h5 id="准备" tabindex="-1"><a class="header-anchor" href="#准备" aria-hidden="true">#</a> 准备</h5><h6 id="为类变量-或称静态变量或静态成员变量-被static修饰的变量-分配内存并赋零值" tabindex="-1"><a class="header-anchor" href="#为类变量-或称静态变量或静态成员变量-被static修饰的变量-分配内存并赋零值" aria-hidden="true">#</a> 为类变量（或称静态变量或静态成员变量，被static修饰的变量）分配内存并赋零值</h6><p>Note：注意不是实例变量 扩展：类变量和局部变量的区别</p><p>类变量会赋零值，局部变量不会赋零值，如果局部变量没有被初始化就会编译报错</p><p>示例：此时A==0</p><figure><img src="'+a+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="解析" tabindex="-1"><a class="header-anchor" href="#解析" aria-hidden="true">#</a> 解析</h5><h6 id="将常量池中的符号引用-类、接口、字段和方法的符号引用-替换为直接引用" tabindex="-1"><a class="header-anchor" href="#将常量池中的符号引用-类、接口、字段和方法的符号引用-替换为直接引用" aria-hidden="true">#</a> 将常量池中的符号引用（类、接口、字段和方法的符号引用）替换为直接引用</h6><p>两个重点：</p><p>####### ● 符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。 符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。</p><p>####### ● 直接引用。可以理解为一个内存地址，或者一个偏移量。 直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</p><p>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p><p>虚拟机实现可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。</p><p>举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p><p>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p><h5 id="初始化-对类的静态变量初始化" tabindex="-1"><a class="header-anchor" href="#初始化-对类的静态变量初始化" aria-hidden="true">#</a> 初始化：对类的静态变量初始化</h5><h6 id="执行所有用户自定义的初始值赋值操作" tabindex="-1"><a class="header-anchor" href="#执行所有用户自定义的初始值赋值操作" aria-hidden="true">#</a> 执行所有用户自定义的初始值赋值操作</h6><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>初始化阶段就是执行类构造器&lt;clinit&gt;()方法的过程。&lt;clinit&gt;()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物，&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的
语句合并产生的，【执行赋值操作和类的静态代码块来初始化静态成员变量】
示例：在此阶段，执行了A=1后又执行了A=2（所有的用户自定义的初始值都在初始化阶段赋值），执行顺序是文件中出现的顺序
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+a+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问 到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访 问</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>·&lt;clinit&gt;()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的
赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 虚拟机规范没有强制约束类加载过程的第一阶段（即：加载）什么时候开始，但对于“初 始化”阶段，有着严格的规定。有且仅有 5 种情况必须立即对类进行初始化</p><h6 id="主动引用与被动引用" tabindex="-1"><a class="header-anchor" href="#主动引用与被动引用" aria-hidden="true">#</a> 主动引用与被动引用</h6><p>这 5 种场景中的行为称为对一个类进行主动引用，除此之外，其它所有引用类的方式都不会触 发初始化，称为被动引用。</p><p>####### 被动引用情形举例 通过子类引用父类的静态字段，不会导致子类初始化。</p><p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义 的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><figure><img src="`+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通过数组定义来引用类，不会触发此类的初始化。</p><p>不会触发数组类型的初始化，但会触发“[L 全类名”这个类的初始化，它由虚拟机自动生 成，直接继承自 java.lang.Object，创建动作由字节码指令 newarray 触发。</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化，调用类和定义常量的类在编译成 Class 之后就没有任何联系了。</p><figure><img src="'+b+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="_5种情形" tabindex="-1"><a class="header-anchor" href="#_5种情形" aria-hidden="true">#</a> 5种情形</h6><p>在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发其初始化。</p><p>对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化。</p><p>初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p><p>虚拟机启动时，用于需要指定一个包含 main() 方法的主类，虚拟机会先初始化这个主类。</p><p>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。</p><p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺 序按部就班地开始（注意是“开始”，而不是“进行”或“完成”）， 而解析阶段则不一定：它在某些情况下可以在初始化后再开始，这是为了支持 Java 语言的运行时绑定。 加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始了。但这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h4 id="接口的加载过程-vs-类加载过程" tabindex="-1"><a class="header-anchor" href="#接口的加载过程-vs-类加载过程" aria-hidden="true">#</a> 接口的加载过程 vs 类加载过程</h4><p>接口加载过程与类加载过程稍有不同。 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要 求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。</p><h4 id="类加载机制和spring中bean的生命周期" tabindex="-1"><a class="header-anchor" href="#类加载机制和spring中bean的生命周期" aria-hidden="true">#</a> 类加载机制和spring中Bean的生命周期</h4><h5 id="执行main方法之前" tabindex="-1"><a class="header-anchor" href="#执行main方法之前" aria-hidden="true">#</a> 执行main方法之前</h5><h6 id="编译" tabindex="-1"><a class="header-anchor" href="#编译" aria-hidden="true">#</a> 编译</h6><p>当使用IntelliJ IDEA等集成开发环境（IDE）编写Java源代码时，编译通常是在您点击运行按钮执行main方法之前自动进行的，IDEA会在后台自动调用Java编译器（javac）来编译更新后的源代码</p><p>修改代码的同时就进行了编译，这样可以立即检查和纠正语法错误和其他编译错误</p><h5 id="执行main方法" tabindex="-1"><a class="header-anchor" href="#执行main方法" aria-hidden="true">#</a> 执行main方法</h5><h6 id="类加载机制和spring中bean的生命周期-1" tabindex="-1"><a class="header-anchor" href="#类加载机制和spring中bean的生命周期-1" aria-hidden="true">#</a> 类加载机制和spring中Bean的生命周期</h6><p>####### 执行main方法后会触发类加载过程，同时如果使用了Spring框架，也会涉及到Spring Bean的生命周期，包括实例化（其实是3步的组合）、属性填充、初始化和销毁等阶段。具体如下： ######## 类加载结果：将字节码文件加载到内存中，生成对应的Class对象。 ######### 加载 ########## 在堆中为Class对象分配内存，生成Class对象 Class对象是类加载后在内存中的一个数据结构，包含了类的结构信息，如类的字段、方法、父类、接口等，可以通过反射机制获取类相关的信息，包括字段、方法、注解等。通过该对象，可以对类进行实例化、调用方法和访问字段等操作。</p><p>验证</p><p>######### 准备 赋零值</p><p>解析</p><p>######### 初始化 赋初始值</p><p>######## Spring Bean的实例化（其实是3步的组合）： 为对象在堆内存中分配内存空间，给属性赋默认值，执行构造函数 在Spring框架中，当Spring容器创建一个Bean的实例时，它会按照以下步骤进行：</p><p>######### 分配内存：Spring容器为Bean对象分配所需的内存空间。这是通过在堆内存中分配一块内存来实现的。内存大小取决于Bean的实例变量和方法所占用的空间。 分配内存</p><p>######### 给属性赋零值：在分配内存之后，Spring容器会为Bean的属性赋予默认值。这些默认值可以是基本数据类型的默认值（如0、false、null），也可以是引用类型的默认值（如null）。这些默认值可以在后续的属性填充阶段中被覆盖或修改。 赋零值</p><p>######### 执行构造函数：在分配内存和属性赋默认值之后，Spring容器会调用Bean的构造函数来创建Bean的实例。构造函数是初始化对象的方法，它可以进行一些必要的设置和初始化操作。构造函数执行后，Bean的实例就被创建并保存在内存中。 赋初始值</p><p>######## 属性注入/属性填充 通过set方法为属性赋值</p><p>######## 初始化 执行init方法（Note:这个不是构造函数，init方法是一个普通方法）</p><h4 id="java类的初始化顺序" tabindex="-1"><a class="header-anchor" href="#java类的初始化顺序" aria-hidden="true">#</a> Java类的初始化顺序</h4><h5 id="待排序项" tabindex="-1"><a class="header-anchor" href="#待排序项" aria-hidden="true">#</a> 待排序项：</h5><p>Java 父类构造函数，父类静态成员变量，父类普通成员变量，父类静态代码块，父类代码块， 子类构造函数 子类静态成员变量，子类普通成员变量，子类静态代码块，子类代码块</p><h6 id="结论" tabindex="-1"><a class="header-anchor" href="#结论" aria-hidden="true">#</a> 结论</h6><p>####### 无继承 静态成员变量（类加载过程的连接阶段的准备阶段）》静态代码块（类加载过程的初始化阶段） 》成员变量》代码块》构造函数（Bean的实例化。Note：SpringBean的生命周期中在实例化之后的属性注入和初始化，可以视为都是Spring自己调用的普通方法实现的）</p><p>####### 有继承 父类静态成员变量》父类静态代码块》子类静态成员变量》子类静态代码块 》父类成员变量》父类代码块》父类构造函数 》子类成员变量》子类代码块》子类构造函数</p><h5 id="没有继承情况下" tabindex="-1"><a class="header-anchor" href="#没有继承情况下" aria-hidden="true">#</a> 没有继承情况下</h5><ol><li><p>执行顺序</p><ol><li>静态成员变量</li><li>静态代码块</li><li>普通成员变量</li><li>普通代码块</li><li>构造函数</li></ol></li><li><p>总结：</p><pre><code> 1. 静态-&gt;普通
 2. 变量-&gt;代码块-&gt;构造函数
 3. 构造函数是最后执行的
</code></pre></li><li><p>代码简易实现：</p><p>public class Father {</p><pre><code> private static String name = &quot;zct&quot;;
 private int age = 50;

 {
     System.out.println(&quot;father age: &quot;+age);
     System.out.println(&quot;father 我是普通代码块&quot;);
 }

 static{
     System.out.println(&quot;father static name: &quot;+name);
     System.out.println(&quot;father 我是静态代码块&quot;);
 }

 public Father(){
     System.out.println(&quot;father 我是构造函数&quot;);
 }
</code></pre><p>}</p></li><li><p>测试：</p><p>@org.junit.Test public void test(){ Father father = new Father(); }</p></li><li><p>测试结果：</p><p>father static name: zct father 我是静态代码块 father age: 50 father 我是普通代码块 father 我是构造函数</p></li></ol><h5 id="有继承情况下" tabindex="-1"><a class="header-anchor" href="#有继承情况下" aria-hidden="true">#</a> 有继承情况下</h5><ol><li><p>执行顺序</p><ol><li>父类的静态成员变量</li><li>父类的静态代码块</li><li>子类的静态成员变量</li><li>子类的静态代码块</li><li>父类的成员变量</li><li>父类的代码块</li><li>父类的构造函数</li><li>子类的成员变量</li><li>子类的代码块</li><li>子类的构造函数</li></ol></li><li><p>总结：</p><ol><li>先静态再普通，先父类再子类 如果子类有静态成员变量和静态代码块，则执行完父类的静态成员变量和静态代码块后，接着执行子类的静态变量和静态代码块， 否则直接按照父类的变量-&gt;代码块-&gt;构造函数，再执行子类的变量-&gt;代码块-&gt;构造函数 需要注意的是子类的静态变量和静态代码块是优先于父类的普通成员变量和代码块以及构造函数的。</li></ol></li><li><p>代码简易实现：</p><p>public class Son extends Father{</p><pre><code> private static String name = &quot;zlc&quot;;
 private int age = 26;
 {
     System.out.println(&quot;son age: &quot;+age);
     System.out.println(&quot;son 我是普通代码块&quot;);
 }

 static{
     System.out.println(&quot;son static name: &quot;+name);
     System.out.println(&quot;son 我是静态代码块&quot;);
 }

 public Son(){
     System.out.println(&quot;son 我是构造函数&quot;);
 }
</code></pre><p>}</p></li><li><p>测试：</p><p>@org.junit.Test public void test(){ Son son = new Son(); }</p></li><li><p>测试结果：</p><p>father static name: zct father 我是静态代码块 son static name: zlc son 我是静态代码块 father age: 50 father 我是普通代码块 father 我是构造函数 son age: 26 son 我是普通代码块 son 我是构造函数</p></li></ol><h3 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器" aria-hidden="true">#</a> 类加载器</h3><h4 id="判断类是否相同" tabindex="-1"><a class="header-anchor" href="#判断类是否相同" aria-hidden="true">#</a> 判断类是否相同</h4><p>任意一个类，都由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性</p><p>同一个类，被不同类加载器加载出来，会是不同的两个类</p><h4 id="加载器种类" tabindex="-1"><a class="header-anchor" href="#加载器种类" aria-hidden="true">#</a> 加载器种类</h4><p>系统提供了3种类加载器。也可以自定义类加载器。</p><figure><img src="`+x+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="_3种类加载器" tabindex="-1"><a class="header-anchor" href="#_3种类加载器" aria-hidden="true">#</a> 3种类加载器</h5><h6 id="启动类加载器" tabindex="-1"><a class="header-anchor" href="#启动类加载器" aria-hidden="true">#</a> 启动类加载器</h6><p>Bootstrap Class Loader</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>负责加载 &lt;JAVA_HOME&gt;\\lib 目录中的所有类库
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h6 id="平台类加载器" tabindex="-1"><a class="header-anchor" href="#平台类加载器" aria-hidden="true">#</a> 平台类加载器</h6><p>Platform Class Loader</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>负责加载 &lt;JAVA_HOME&gt;\\lib\\ext 目录中的所有类库
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>原本的扩展类加载器Extension Class Loader，JDK9改了，引入模块，改为平台类加载器</p><h6 id="应用程序类加载器-系统类加载器" tabindex="-1"><a class="header-anchor" href="#应用程序类加载器-系统类加载器" aria-hidden="true">#</a> 应用程序类加载器/系统类加载器</h6><p>Application Class Loader 负责加载用户类路径（classpath）上所指定的类库</p><p>程序中默认的类加载器</p><h4 id="双亲委派模型" tabindex="-1"><a class="header-anchor" href="#双亲委派模型" aria-hidden="true">#</a> 双亲委派模型</h4><p>描述类加载器之间的层次关系</p><figure><img src="`+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>目的：确保每个类的唯一</p><p>工作过程：优先委派给父类去加载，父类无法加载，则自己尝试加载</p><p>在 java.lang.ClassLoader 中的 loadClass() 方法中实现该过程。</p><h5 id="如何破坏双亲委派机制" tabindex="-1"><a class="header-anchor" href="#如何破坏双亲委派机制" aria-hidden="true">#</a> 如何破坏双亲委派机制</h5><p>如果不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载</p><p>如果想打破双亲委派模型则需要重写 loadClass()方法</p><h4 id="扩展-tomcat-的类加载机制" tabindex="-1"><a class="header-anchor" href="#扩展-tomcat-的类加载机制" aria-hidden="true">#</a> 扩展：Tomcat 的类加载机制</h4><p>Tomcat 是主流的 Java Web 服务器之一，为了实现一些特殊的功能需求，自定义了一些类加载器。</p><p>Tomcat类加载器</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Tomcat 实际上是破坏了双亲委派模型的。</p><p>Tomact 是 web 容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如多个应用都要依赖 hollis.jar，但是 A 应用需要依赖 1.0.0 版本，但是 B 应用需要依赖 1.0.1 版本。这两个版本中都有一个类是 com.hollis.Test.class。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。</p><p>所以，Tomcat 破坏了双亲委派原则，提供隔离的机制，为每个 web 容器单独提供一个 WebAppClassLoader 加载器。每一个 WebAppClassLoader 负责加载本身的目录下的 class 文件，加载不到时再交 CommonClassLoader 加载，这和双亲委派刚好相反。</p><h2 id="_3、自动内存管理" tabindex="-1"><a class="header-anchor" href="#_3、自动内存管理" aria-hidden="true">#</a> 3、自动内存管理</h2><h3 id="内存区域划分" tabindex="-1"><a class="header-anchor" href="#内存区域划分" aria-hidden="true">#</a> 内存区域划分</h3><h4 id="划分为5个部分" tabindex="-1"><a class="header-anchor" href="#划分为5个部分" aria-hidden="true">#</a> 划分为5个部分</h4><figure><img src="'+C+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>JDK1.8 元空间替代了方法区。元空间不在虚拟机中，而是使用本地内存。</p><figure><img src="'+S+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="线程私有区" tabindex="-1"><a class="header-anchor" href="#线程私有区" aria-hidden="true">#</a> 线程私有区</h4><p>生命周期：随线程生死，随方法出入栈</p><h5 id="虚拟机栈-vm-stack" tabindex="-1"><a class="header-anchor" href="#虚拟机栈-vm-stack" aria-hidden="true">#</a> 虚拟机栈 VM Stack</h5><p>（服务于：执行Java方法，也就是执行字节码）</p><h6 id="栈帧内存空间" tabindex="-1"><a class="header-anchor" href="#栈帧内存空间" aria-hidden="true">#</a> 栈帧内存空间</h6><p>虚拟机栈描述的是Java方法执行的内存模型：每个Java方法被执行的时候，JVM都会同步创建一个栈帧（Stack Frame）。每一个方法从被调用到执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><figure><img src="'+j+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>####### 存放 局部变量表</p><p>######## 操作数栈 放临时的操作数，操作完成后出栈赋值给局部变量</p><p>动态链接</p><p>方法出口信息</p><h6 id="两类异常状况" tabindex="-1"><a class="header-anchor" href="#两类异常状况" aria-hidden="true">#</a> 两类异常状况</h6><p>####### StackOverflowError 栈深度超过允许的最大深度</p><p>####### OutOfMemoryError 无法申请到足够内存</p><p>HotSpot不会进行栈的动态扩展，但每个方法初次申请如果内存不够，会报OOM</p><h5 id="本地方法栈-c栈-native-method-stack" tabindex="-1"><a class="header-anchor" href="#本地方法栈-c栈-native-method-stack" aria-hidden="true">#</a> 本地方法栈/C栈 Native Method Stack</h5><p>（服务于：执行虚拟机本地（Native）方法，很多Native方法都是用C语言实现的） HotSpot虚拟机把本地方法栈和虚拟机栈合二为一了</p><h5 id="程序计数器-program-counter-register" tabindex="-1"><a class="header-anchor" href="#程序计数器-program-counter-register" aria-hidden="true">#</a> 程序计数器 Program Counter Register</h5><h6 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h6><p>当前线程所执行的字节码的行号指示器</p><p>执行Java方法时，程序计数器的值为正在执行的虚拟机字节码指令的地址；执行本地（Native）方法时，程序计数器值为空（Undefined）</p><h6 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h6><p>字节码解释器通过改变程序计数器来依次读取字节码指令，从而实现代码的流程控制</p><p>多线程场景，线程上下文切换后，程序计数器确保线程恢复到正确的执行位置</p><h6 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h6><p>是一块较小的内存空间</p><p>唯一一个不会出现OOM的内存区域</p><h4 id="线程共享区" tabindex="-1"><a class="header-anchor" href="#线程共享区" aria-hidden="true">#</a> 线程共享区</h4><h5 id="堆-heap" tabindex="-1"><a class="header-anchor" href="#堆-heap" aria-hidden="true">#</a> 堆 Heap</h5><p>存放实例对象</p><h6 id="对象一定分配在堆中吗-有没有了解逃逸分析技术" tabindex="-1"><a class="header-anchor" href="#对象一定分配在堆中吗-有没有了解逃逸分析技术" aria-hidden="true">#</a> 对象一定分配在堆中吗？有没有了解逃逸分析技术？</h6><p>并不是所有实例对象都分配在堆上。现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段使得实例对象不分配在堆上。 ####### 逃逸分析 在编译期间，JIT 会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。</p><p>目的：看是否能进行优化，将对象不分配在堆上，从而减少堆内存的分配压力</p><p>######## 定义 逃逸分析是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。</p><p>通俗讲：局部对象被外部（外部方法，外部线程）所调用</p><p>######## 逃逸强度</p><figure><img src="'+M+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>######### 不逃逸</p><figure><img src="'+J+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>######### 方法逃逸 当一个对象被 new 出来之后，它可能被外部所调用，如果是作为参数传递到外部了，就称之为方法逃逸。</p><p>######### 线程逃逸 如果对象还有可能被外部线程访问到，例如赋值给可以在其它线程中访问的实例变量，这种就被称为线程逃逸。</p><p>####### 逃逸分析后的优化点 ######## 栈上分配</p><p>适用：不逃逸&amp;方法逃逸 如果确定一个对象不会逃逸到线程之外，那么就可以考虑将这个对象在栈上分配，对象占用的内存随着栈帧出栈而销毁，这样一来，垃圾收集的压力就降低很多。</p><p>######## 同步消除</p><p>适用：不逃逸&amp;方法逃逸 线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。</p><p>######## 标量替换</p><p>适用：不逃逸 如果一个数据是基本数据类型，不可拆分，它就被称之为标量。把一个 Java 对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么可以不创建对象，直接用创建若干个成员变量代替，可以让对象的成员变量在栈上分配和读写。</p><h6 id="细分" tabindex="-1"><a class="header-anchor" href="#细分" aria-hidden="true">#</a> 细分</h6><p>####### 经典分代 ######## 部分垃圾收集器共同设计风格 Eden : From Survivor : To Survivor=8:1:1</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>1）new出来的对象先放Eden区 2）Eden区满了，就把Eden区存活对象copy到From Survivor区（Minor GC） 3）Eden区和From Survivor区满了，就把两个区存活对象copy到To Survivor区（Minor GC） 4）年轻代空间都满了，就把年轻代存活对象copy到年老代（Minor GC） 5）年老代满了，启动Full GC，对所有3代进行全面回收，耗时很长</p><p>####### 不采用分代 部分垃圾收集器的设计风格</p><p>####### 线程私有的分配缓冲区（TLAB，Thread Local Allocation Buffer） 目的：更快地分配内存，提升对象分配效率</p><h6 id="特点-1" tabindex="-1"><a class="header-anchor" href="#特点-1" aria-hidden="true">#</a> 特点</h6><p>JVM所管理的内存中最大的一块</p><p>JVM调优主要是优化堆区内存的使用效率</p><p>Java堆是垃圾收集器管理的内存区域，也被称为GC堆</p><h6 id="堆大小配置" tabindex="-1"><a class="header-anchor" href="#堆大小配置" aria-hidden="true">#</a> 堆大小配置</h6><p>通过参数-Xmx和-Xms设定</p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="异常状况" tabindex="-1"><a class="header-anchor" href="#异常状况" aria-hidden="true">#</a> 异常状况</h6><p>####### OutOfMemoryError Java堆没有足够内存进行实例分配，并且堆也无法再扩展</p><h5 id="jdk7-方法区-method-area-jdk8-元空间-meta-space" tabindex="-1"><a class="header-anchor" href="#jdk7-方法区-method-area-jdk8-元空间-meta-space" aria-hidden="true">#</a> JDK7 方法区 Method Area（JDK8 元空间 Meta Space）</h5><h6 id="存放" tabindex="-1"><a class="header-anchor" href="#存放" aria-hidden="true">#</a> 存放</h6><p>####### 类型信息（字节码文件） ######## Note：类加载过程中生成的Class对象，存在于堆中，不在方法区，静态变量和Class对象绑定在一起，也在堆中 周志明《深入理解JVM-第三版》里说明了</p><figure><img src="'+G+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>####### 常量 ######## 运行时常量池 Runtime Constant Pool 这个区域是包含在方法区里的，不过，对于JVM的操作而言，它是一个核心的角色。因此在JVM规范里特别提到了它的重要性。除了包含每个类和接口的常量，它也包含了所有方法和变量的引用。简而言之，当一个方法或者变量被引用时，JVM通过运行时常量区来查找方法或者变量在内存里的实际地址。</p><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中[</p><p>并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><p>即时编译器编译后的代码缓存</p><p>内存回收效率低，方法区中的信息一般需要长期存在，GC分代划分作为永久代。主要回收目标：常量池的回收和类型的卸载</p><p>JDK1.8以后，元空间替代了方法区 最大区别：元空间并不在虚拟机中，而是使用本地内存 因此，默认情况下，元空间的大小仅受本地内存限制</p><h3 id="内存分配" tabindex="-1"><a class="header-anchor" href="#内存分配" aria-hidden="true">#</a> 内存分配</h3><p>内存回收决定内存分配</p><h4 id="对象的内存布局" tabindex="-1"><a class="header-anchor" href="#对象的内存布局" aria-hidden="true">#</a> 对象的内存布局</h4><p>分为3块区域</p><figure><img src="'+z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="对象头" tabindex="-1"><a class="header-anchor" href="#对象头" aria-hidden="true">#</a> 对象头</h5><h6 id="mark-word-记录运行时数据" tabindex="-1"><a class="header-anchor" href="#mark-word-记录运行时数据" aria-hidden="true">#</a> Mark Word 记录运行时数据</h6><p>哈希码</p><p>GC分代年龄</p><p>####### 锁相关信息 锁状态标志</p><p>线程持有的锁</p><p>偏向线程ID</p><p>偏向时间戳</p><h6 id="类型指针" tabindex="-1"><a class="header-anchor" href="#类型指针" aria-hidden="true">#</a> 类型指针</h6><p>通过该指针确定对象属于哪个类</p><p>对象访问方式为直接指针访问方式（HotSpot采用此），则需要； 对象访问方式为句柄访问方式，则不需要</p><p>如果对象是数组：数组长度</p><h5 id="实例数据" tabindex="-1"><a class="header-anchor" href="#实例数据" aria-hidden="true">#</a> 实例数据</h5><h6 id="成员变量" tabindex="-1"><a class="header-anchor" href="#成员变量" aria-hidden="true">#</a> 成员变量</h6><p>父类的成员变量也包括进来</p><h5 id="对齐填充" tabindex="-1"><a class="header-anchor" href="#对齐填充" aria-hidden="true">#</a> 对齐填充</h5><h6 id="确保总长度是8字节的整数倍" tabindex="-1"><a class="header-anchor" href="#确保总长度是8字节的整数倍" aria-hidden="true">#</a> 确保总长度是8字节的整数倍</h6><p>对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全</p><h4 id="对象的创建-new过程-实例化过程" tabindex="-1"><a class="header-anchor" href="#对象的创建-new过程-实例化过程" aria-hidden="true">#</a> 对象的创建/new过程/实例化过程</h4><h5 id="类加载检查" tabindex="-1"><a class="header-anchor" href="#类加载检查" aria-hidden="true">#</a> 类加载检查</h5><p>检查常量池中是否有这个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、连接和初始化过。如果没有，那么必须先执行相应的类加载过程。</p><h5 id="分配内存" tabindex="-1"><a class="header-anchor" href="#分配内存" aria-hidden="true">#</a> 分配内存</h5><p>所需内存大小在类加载完成便可确认，在堆中分配对应大小内存空间</p><p>Note：选择垃圾收集器不同，内存分配方式不同</p><figure><img src="'+P+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="两种方式" tabindex="-1"><a class="header-anchor" href="#两种方式" aria-hidden="true">#</a> 两种方式</h6><p>####### 指针碰撞 Bump The Pointer ######## Java堆内存规整 垃圾回收算法采用的标记复制算法或标记整理算法</p><p>指针作为空闲内存和已使用内存的分界点，分配内存只需移动指针，向空闲内存方向移动对象大小的距离</p><p>####### 空闲列表 Free List ######## Java堆内存不规整 垃圾回收算法采用的标记清除算法</p><p>空闲列表维护了空闲可用的内存块，分配内存只需从中找到一块比对象大的内存分配给对象</p><h6 id="jvm-里-new-对象时-堆会发生抢占吗-jvm-是怎么设计来保证线程安全的" tabindex="-1"><a class="header-anchor" href="#jvm-里-new-对象时-堆会发生抢占吗-jvm-是怎么设计来保证线程安全的" aria-hidden="true">#</a> JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？</h6><p>####### 堆抢占 会，假设 JVM 虚拟机上，每一次 new 对象时，指针就会向右移动一个对象 size 的距离，一个线程正在给 A 对象分配内存，指针还没有来的及修改，另一个为 B 对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。</p><figure><img src="'+X+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>####### 2种解决方案 ● 采用 CAS 分配重试的方式来保证更新操作的原子性</p><p>● 每个线程在 Java 堆中预先分配一小块内存，也就是本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定</p><h6 id="内存分配规则" tabindex="-1"><a class="header-anchor" href="#内存分配规则" aria-hidden="true">#</a> 内存分配规则</h6><p>分配规则不固定，分配规则取决于选择的垃圾收集器组合以及相关的参数配置</p><p>####### 普遍内存分配规则 对象优先在Eden分配</p><p>######## 对象进入老年代4种情形 ######### 大对象直接进老年代 一个大对象（占用大量连续内存空间的对象，一般是数组，长字符串等）直接进入老年代，避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制</p><p>-XX:PretenureSizeThreshold</p><p>######### 长期存活对象将进入老年代 JVM 给每个对象定义了一个对象年龄计数器（对象头里的GC分代年龄）。当新生代发生一次 Minor GC 后，存活下来的对象年龄 +1，当年龄超过一定值时（默认是15），就将超过该值的所有对象转移到老年代中去。</p><p>-XX:MaxTenuringThreshold</p><p>######### 动态对象年龄判定 如果当前新生代的 Survivor 中，相同年龄所有对象大小的总和大于 Survivor 空间的一半（众数），年龄&gt;= 该年龄（众数）的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p><p>######### 空间分配担保 空间分配担保：新生代有大量对象存活，Survivor无法容纳的对象直接进入老年代。</p><p>只要老年代的连续空间&lt;新生代对象总大小或者历次晋升的平均大小，即无法给新生代作担保，就会进行 Full GC。</p><p>赋零值</p><p>设置对象头信息</p><p>赋初始值</p><h4 id="对象的访问方式" tabindex="-1"><a class="header-anchor" href="#对象的访问方式" aria-hidden="true">#</a> 对象的访问方式</h4><p>栈上的引用reference访问堆中实例对象的方式</p><h5 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h5><p>Note：根据reference存放的地址类型不同，访问对象方式不同</p><h6 id="直接指针访问方式" tabindex="-1"><a class="header-anchor" href="#直接指针访问方式" aria-hidden="true">#</a> 直接指针访问方式</h6><p>Note：HotSpot采用此，但有例外情况用句柄访问方式 reference存放实例对象的地址</p><p>对象头里的类型指针指向方法区中的类型数据地址（Note：对象类型数据地址不是Class对象的地址）</p><figure><img src="'+T+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>优：访问对象只需要一次寻址操作，性能上比句柄访问方式快一倍；堆中不需要分配“句柄池”的内存空间</p><p>缺：对象头需存储类型数据的地址</p><h6 id="句柄访问方式" tabindex="-1"><a class="header-anchor" href="#句柄访问方式" aria-hidden="true">#</a> 句柄访问方式</h6><p>reference存放句柄地址</p><p>堆中有块“句柄池”的内存空间，句柄包含了对象实例数据与类型数据的地址信息。</p><figure><img src="'+R+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>优：对象头无需存储类型数据的地址</p><p>缺：堆中需要分配“句柄池”的内存空间</p><h3 id="内存回收" tabindex="-1"><a class="header-anchor" href="#内存回收" aria-hidden="true">#</a> 内存回收</h3><p>哪些内存需要回收：判断对象是否存活 什么时候回收：Mnior GC 和 Full GC 怎么回收：垃圾收集器与垃圾收集算法</p><h4 id="关注区域" tabindex="-1"><a class="header-anchor" href="#关注区域" aria-hidden="true">#</a> 关注区域</h4><p>程序计数器、虚拟机栈、本地方法栈随线程而生，也随线程而灭；栈帧随着方法的开始而入 栈，随着方法的结束而出栈。这几个区域的内存分配和回收都具有确定性，在这几个区域内不 需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了</p><p>而对于 Java 堆和方法区，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分 配和回收都是动态的，垃圾收集器所关注的正是这部分内存</p><h4 id="哪些内存需要回收" tabindex="-1"><a class="header-anchor" href="#哪些内存需要回收" aria-hidden="true">#</a> 哪些内存需要回收</h4><h5 id="堆" tabindex="-1"><a class="header-anchor" href="#堆" aria-hidden="true">#</a> 堆</h5><p>判定对象是否存活 若一个对象不被任何对象或变量引用，那么它就是无效对象，需要被回收</p><h6 id="引用" tabindex="-1"><a class="header-anchor" href="#引用" aria-hidden="true">#</a> 引用</h6><p>JDK2之前，一个对象只有 被引用或者没有被引用两种状态</p><p>JDK2之后，引用分为4类 4 种引用强度依次逐渐减弱</p><figure><img src="'+V+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>####### 4种引用 ######## 强引用 Strong Referrence 存在引用就不会被回收</p><p>最传统的普遍存在的引用赋值 Object obj = new Object();</p><p>######## 软引用 Soft Reference 内存溢出前将被回收</p><p>食之无味，弃之可惜的对象（还有用，但非必须），内存够保留，内存紧张可抛弃</p><p>通常用来实现缓存，如果有空闲内存则保留，内存不足时清理掉</p><p>######## 弱引用 Weak Reference 下次垃圾回收将被回收</p><p>######## 虚引用/幽灵引用/幻影引用<br> Phantom Reference 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。它仅仅是提供了一种确保对象被finalize之后，做某些事情的机制，比如，通常用来做所谓的Post-Mortem清理机制</p><h6 id="算法" tabindex="-1"><a class="header-anchor" href="#算法" aria-hidden="true">#</a> 算法</h6><p>####### 引用计数法 在对象头维护着一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。 当计数器为 0 时，就认为该对象无效了。</p><p>存在问题：循环引用</p><p>主流JVM一般不采用此</p><p>####### 可达性分析法 所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效 对象。</p><p>将一系列 GC Roots 作为初始的存活对象合集（GC Root Set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。</p><figure><img src="'+E+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>######## GC Roots ######### 栈内 虚拟机栈（栈帧中的本地变量表）中引用的对象</p><p>本地方法栈中引用的对象</p><p>######### 方法区内 方法区中常量引用的对象</p><p>方法区中类静态属性引用的对象</p><p>循环引用问题的解决：GCRoots是不会被堆中对象所引用的，这样就不会有循环引用的问题</p><p>主流JVM一般采用此</p><h6 id="finalize" tabindex="-1"><a class="header-anchor" href="#finalize" aria-hidden="true">#</a> finalize</h6><p>如果对象重写了finalize()且未被执行过（只会被系统调用一次），对象会被放入F-Queue队列中，虚拟机会以较低的优先级执行这些 finalize()方法，但不会确保所有的 finalize() 方法都会执行结束。如果 finalize() 方法出现耗时操作，虚拟机就直接停止指向该方法，将对象清除。如果在执行finalize() 方法时，将 this 赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。</p><h5 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区" aria-hidden="true">#</a> 方法区</h5><p>主要回收目标：常量池的回收和类型的卸载</p><h6 id="判断废弃常量" tabindex="-1"><a class="header-anchor" href="#判断废弃常量" aria-hidden="true">#</a> 判断废弃常量</h6><p>常量池中不被任何变量或对象引用的常量</p><h6 id="判断无用的类" tabindex="-1"><a class="header-anchor" href="#判断无用的类" aria-hidden="true">#</a> 判断无用的类</h6><p>（需同时满足3个条件才允许被回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了必然会回收） Note：在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。 该类的所有实例都已经被回收</p><p>####### 加载该类的 类加载器ClassLoader 已经被回收 这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的</p><p>该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p><p>Note：一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区时创建，在方法区该类被删除时清除。</p><h4 id="gc" tabindex="-1"><a class="header-anchor" href="#gc" aria-hidden="true">#</a> GC</h4><p>什么时候回收</p><h5 id="minor-gc-轻量级回收" tabindex="-1"><a class="header-anchor" href="#minor-gc-轻量级回收" aria-hidden="true">#</a> Minor GC 轻量级回收</h5><p>回收新生代，比较频繁，一般速度比较快</p><h6 id="频繁minor-gc" tabindex="-1"><a class="header-anchor" href="#频繁minor-gc" aria-hidden="true">#</a> 频繁minor gc</h6><p>根因：新生代空间太小，Eden区很快被填满 解决：增大新生代空间（-Xmn）</p><h5 id="full-gc-major-gc-重量级回收" tabindex="-1"><a class="header-anchor" href="#full-gc-major-gc-重量级回收" aria-hidden="true">#</a> Full GC/Major GC 重量级回收</h5><p>回收整个Java堆和方法区，速度一般会比 Minor GC 慢 10 倍以上</p><h6 id="触发full-gc的情形" tabindex="-1"><a class="header-anchor" href="#触发full-gc的情形" aria-hidden="true">#</a> 触发Full GC的情形</h6><p>####### 老年代空间不足 若Full GC后空间依旧不足，则会抛出如下错误： java.lang.OutOfMemoryError: Java heap space</p><p>####### 永久代空间不足 当系统要加载的类、反射的类和 调用的方法较多时，永久代可能会被占满，会触发 Full GC</p><p>若Full GC后空间依旧不足，则会抛出如下错误： java.lang.OutOfMemoryError: PermGen space</p><p>####### 显式调用System.gc()方法 此方法的调用是建议 JVM 进行 Full GC，注意这只是建议而非一定，但在很多情况下它会 触发 Full GC，从而增加 Full GC 的频率。</p><p>通常情况下我们只需要让虚拟机自己去管理内存即可，我们可以通过 -XX:+ DisableExplicitGC 来禁止调用 System.gc()。</p><p>####### 老年代估计担保会失败 老年代的连续空间小于新生代对象总大小或者历次晋升的平均大小</p><p>通过java命令改变分配堆空间的运行策略</p><h6 id="频繁full-gc" tabindex="-1"><a class="header-anchor" href="#频繁full-gc" aria-hidden="true">#</a> 频繁full gc</h6><p>####### 清楚哪些原因触发full gc 大对象（比如 SQL 查询未做分页） 长生命周期对象 内存泄漏（比如 IO 对象使用完后未调用 close 方法释放资源） 显式调用gc方法 JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden 区和 S 区的大小、元空间大小、垃圾回收算法等等。</p><p>####### 清楚可用的排查工具 ● 公司监控系统：大部分公司都会有，可全方位监控JVM的各项指标</p><p>● 可视化堆内存分析工具：JVisualVM、MAT等</p><p>● JDK自带工具：jmap、jstat等常用命令</p><h1 id="查看堆内存各区域的使用率以及gc情况" tabindex="-1"><a class="header-anchor" href="#查看堆内存各区域的使用率以及gc情况" aria-hidden="true">#</a> 查看堆内存各区域的使用率以及GC情况</h1><p>jstat -gcutil -h20 pid 1000</p><h1 id="查看堆内存中的存活对象-并按空间排序" tabindex="-1"><a class="header-anchor" href="#查看堆内存中的存活对象-并按空间排序" aria-hidden="true">#</a> 查看堆内存中的存活对象，并按空间排序</h1><p>jmap -histo pid | head -n20</p><h1 id="dump堆内存文件" tabindex="-1"><a class="header-anchor" href="#dump堆内存文件" aria-hidden="true">#</a> dump堆内存文件</h1><p>jmap -dump:format=b,file=heap pid</p><p>####### 排查指南 ● 查看监控，以了解出现问题的时间点以及当前 FGC 的频率（可对比正常情况看频率是否正常） ● 了解该时间点之前有没有程序上线、基础组件升级等情况。 ● 了解 JVM 的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析 JVM 参数设置是否合理。 ● 再对步骤 1 中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用 gc 方法比较容易排查。 ● 针对大对象或者长生命周期对象导致的 FGC，可通过 jmap -histo 命令并结合 dump 堆内存文件作进一步分析，需要先定位到可疑对象。 ● 通过可疑对象定位到具体代码再次分析，这时候要结合 GC 原理和 JVM 参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。</p><h4 id="怎么回收" tabindex="-1"><a class="header-anchor" href="#怎么回收" aria-hidden="true">#</a> 怎么回收</h4><p>略 垃圾收集算法</p><p>垃圾收集器</p><h3 id="内存泄漏、内存溢出" tabindex="-1"><a class="header-anchor" href="#内存泄漏、内存溢出" aria-hidden="true">#</a> 内存泄漏、内存溢出</h3><h4 id="两者关系" tabindex="-1"><a class="header-anchor" href="#两者关系" aria-hidden="true">#</a> 两者关系</h4><h5 id="内存泄漏-申请的内存空间没有被正确释放-空间不用了但还占着-占着茅坑不拉屎" tabindex="-1"><a class="header-anchor" href="#内存泄漏-申请的内存空间没有被正确释放-空间不用了但还占着-占着茅坑不拉屎" aria-hidden="true">#</a> 内存泄漏：申请的内存空间没有被正确释放，空间不用了但还占着（占着茅坑不拉屎）</h5><p>内存溢出：申请内存时，发现内存满了，不够用了（坑全满了） 两者关系：内存泄漏会导致内存溢出 图解：蹲坑 正常情况：占坑的都是在用的，也有很多空着的 内存泄漏：部分占坑的没在用了，但仍占着坑（那两个笑脸） 内存溢出：坑全满了</p><figure><img src="'+O+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="内存溢出异常-oom-outofmemeryerror" tabindex="-1"><a class="header-anchor" href="#内存溢出异常-oom-outofmemeryerror" aria-hidden="true">#</a> 内存溢出异常 OOM （OutOfMemeryError）</h4><p>除程序计数器以外的内存区域，都有可能OOM</p><p>垃圾收集机制避免了大部分的内存溢出异常</p><p>当需要排查内存溢出、内存泄漏的问题，当垃圾收集成为系统达到更高并发量的瓶颈时，必须对内存动态分配和内存回收技术实施必要的监控和调节</p><h5 id="手写内存溢出" tabindex="-1"><a class="header-anchor" href="#手写内存溢出" aria-hidden="true">#</a> 手写内存溢出</h5><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+F+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="内存泄露" tabindex="-1"><a class="header-anchor" href="#内存泄露" aria-hidden="true">#</a> 内存泄露</h4><h5 id="情形" tabindex="-1"><a class="header-anchor" href="#情形" aria-hidden="true">#</a> 情形</h5><h6 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h6><figure><img src="'+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>● 静态集合类：静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。</p><p>● 单例模式：单例对象在初始化后会以静态变量的方式在JVM的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被GC回收。</p><p>● 连接未释放：创建的连接不再使用时，需要调用 close 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象。</p><p>● 变量作用域太大：变量定义的作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。</p><p>● hash值发生变化：对象 Hash 值改变，使用 HashMap、HashSet 等容器中时候，由于对象修改之后的 Hash 值和存储进容器时的 Hash 值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。说句题外话，这也是为什么 String 类型被设置成了不可变类型。</p><p>● ThreadLocal 使用不当：ThreadLocal 的弱引用导致内存泄漏也是个老生常谈的话题了，使用完 ThreadLocal 一定要记得使用 remove 方法来进行清除。</p><h5 id="如何定位" tabindex="-1"><a class="header-anchor" href="#如何定位" aria-hidden="true">#</a> 如何定位</h5><p>怎么处理 内存泄漏是内在病源，外在病症表现可能有：</p><ul><li>应用程序长时间连续运行时性能严重下降</li><li>CPU 使用率飙升，甚至到 100%</li><li>频繁 Full GC，各种报警，例如接口超时报警等</li><li>应用程序抛出 OutOfMemoryError 错误</li><li>应用程序偶尔会耗尽连接对象</li></ul><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+L+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="jvm调优" tabindex="-1"><a class="header-anchor" href="#jvm调优" aria-hidden="true">#</a> JVM调优</h3><h4 id="有哪些常用的命令行性能监控和故障处理工具" tabindex="-1"><a class="header-anchor" href="#有哪些常用的命令行性能监控和故障处理工具" aria-hidden="true">#</a> 有哪些常用的命令行性能监控和故障处理工具？</h4><h5 id="操作系统工具" tabindex="-1"><a class="header-anchor" href="#操作系统工具" aria-hidden="true">#</a> 操作系统工具</h5><p>top：显示系统整体资源使用情况 vmstat：监控内存和 CPU iostat：监控 IO 使用 netstat：监控网络使用</p><h5 id="jdk性能监控工具" tabindex="-1"><a class="header-anchor" href="#jdk性能监控工具" aria-hidden="true">#</a> JDK性能监控工具</h5><p>jps：虚拟机进程查看 jstat：虚拟机运行时信息查看 jinfo：虚拟机配置查看 jmap：内存映像（导出） jhat：堆转储快照分析 jstack：Java 堆栈跟踪 jcmd：实现上面除了 jstat 外所有命令的功能</p><h4 id="了解哪些可视化的性能监控和故障处理工具" tabindex="-1"><a class="header-anchor" href="#了解哪些可视化的性能监控和故障处理工具" aria-hidden="true">#</a> 了解哪些可视化的性能监控和故障处理工具？</h4><h5 id="jdk自带的" tabindex="-1"><a class="header-anchor" href="#jdk自带的" aria-hidden="true">#</a> JDK自带的</h5><p>JConsole</p><p>VisualVM</p><p>Java Mission Control</p><h5 id="第三方工具" tabindex="-1"><a class="header-anchor" href="#第三方工具" aria-hidden="true">#</a> 第三方工具</h5><p>MAT：Java堆内存分析工具</p><p>GCisto：GC日志分析工具</p><p>GCViewer：GC日志分析工具</p><p>JProfiler：商用的性能分析工具</p><p>arthas：阿里开源诊断工具</p><p>async-profiler：Java应用性能分析工具，开源、火焰图、跨平台</p><h4 id="jvm常见参数配置" tabindex="-1"><a class="header-anchor" href="#jvm常见参数配置" aria-hidden="true">#</a> JVM常见参数配置</h4><h5 id="堆配置" tabindex="-1"><a class="header-anchor" href="#堆配置" aria-hidden="true">#</a> 堆配置</h5><p>-Xms:初始堆大小 -Xmx:最大堆大小 -Xmn:设置新生代（年轻代）大小 -XX:NewSize=n:设置年轻代大小 -XX:NewRatio=n:设置年轻代和年老代的比值。如：为 3 表示年轻代和年老代比值为 1：3，年轻代占整个年轻代年老代和的 1/4 -XX:SurvivorRatio=n:年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如 3 表示 Eden： 3 Survivor：2，一个 Survivor 区占整个年轻代的 1/5 -XX:MaxPermSize=n:设置持久代大小</p><h5 id="收集器配置" tabindex="-1"><a class="header-anchor" href="#收集器配置" aria-hidden="true">#</a> 收集器配置</h5><p>-XX:+UseSerialGC:使用Serial收集器 -XX:+UseParallelGC:使用Parallel收集器 -XX:+UseParalledlOldGC:使用ParalledlOld收集器 -XX:+UseConcMarkSweepGC:使用CMS收集器</p><h5 id="parallel收集器配置" tabindex="-1"><a class="header-anchor" href="#parallel收集器配置" aria-hidden="true">#</a> Parallel收集器配置</h5><p>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的 CPU 数。并行收集线程数 -XX:MaxGCPauseMillis=n:设置并行收集最大的暂停时间（如果到这个时间了，垃圾回收器依然没有回收完，也会停止回收） -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为：1/(1+n) -XX:+CMSIncrementalMode:设置为增量模式。适用于单 CPU 情况 -XX:ParallelGCThreads=n:设置并发收集器年轻代手机方式为并行收集时，使用的 CPU 数。并行收集线程数</p><h5 id="打印gc回收的过程日志信息" tabindex="-1"><a class="header-anchor" href="#打印gc回收的过程日志信息" aria-hidden="true">#</a> 打印GC回收的过程日志信息</h5><p>-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:filename</p><h4 id="jvm调优流程" tabindex="-1"><a class="header-anchor" href="#jvm调优流程" aria-hidden="true">#</a> JVM调优流程</h4><figure><img src="'+D+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>案例：电商公司的运营后台系统，偶发性的引发 OOM 异常，堆内存溢出</p><figure><img src="'+q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="线上服务-cpu-占用过高怎么排查" tabindex="-1"><a class="header-anchor" href="#线上服务-cpu-占用过高怎么排查" aria-hidden="true">#</a> 线上服务 CPU 占用过高怎么排查？</h4><p>问题分析：CPU 高一定是某个程序长期占用了 CPU 资源。</p><figure><img src="'+N+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+U+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="内存飙高问题怎么排查" tabindex="-1"><a class="header-anchor" href="#内存飙高问题怎么排查" aria-hidden="true">#</a> 内存飙高问题怎么排查？</h4><figure><img src="'+H+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>频繁 minor gc 怎么办？</p><p>频繁 Full GC 怎么办？</p><p>内存泄漏，内存溢出问题如何定位？</p><h2 id="_4、怎么回收" tabindex="-1"><a class="header-anchor" href="#_4、怎么回收" aria-hidden="true">#</a> 4、怎么回收</h2><p>垃圾收集器 垃圾收集算法是内存回收的方法论 垃圾收集器就是内存回收的具体实现</p><h3 id="垃圾收集算法" tabindex="-1"><a class="header-anchor" href="#垃圾收集算法" aria-hidden="true">#</a> 垃圾收集算法</h3><h4 id="标记复制算法-mark-copy" tabindex="-1"><a class="header-anchor" href="#标记复制算法-mark-copy" aria-hidden="true">#</a> 标记复制算法 Mark-Copy</h4><p>将存活对象复制到另一块，然后把当前块内存空间全部清空</p><figure><img src="'+K+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>适用于新生代，存活对象比较少的情形</p><p>缺点：存在空间的浪费</p><h5 id="实际应用" tabindex="-1"><a class="header-anchor" href="#实际应用" aria-hidden="true">#</a> 实际应用</h5><h6 id="解决空间利用率问题" tabindex="-1"><a class="header-anchor" href="#解决空间利用率问题" aria-hidden="true">#</a> 解决空间利用率问题</h6><p>新生代分区及其比例 Eden : From Survivor: To Survivor = 8:1:1</p><p>这样只有10%的内存被浪费</p><p>但无法按保证每次回收存活对象不超过10%的空间，当Survivor空间不够，需要依赖老年代进行分配担保</p><h6 id="分配担保" tabindex="-1"><a class="header-anchor" href="#分配担保" aria-hidden="true">#</a> 分配担保</h6><p>浪费的内存空间少了，就需要老年代进行分配担保</p><h4 id="标记清除算法-mark-sweep" tabindex="-1"><a class="header-anchor" href="#标记清除算法-mark-sweep" aria-hidden="true">#</a> 标记清除算法 Mark-Sweep</h4><p>将可回收对象清除</p><figure><img src="'+W+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>适用于老年代，存活对象比较多的情形</p><h5 id="缺点-内存空间的碎片化问题" tabindex="-1"><a class="header-anchor" href="#缺点-内存空间的碎片化问题" aria-hidden="true">#</a> 缺点：内存空间的碎片化问题</h5><p>产生大量不连续的内存碎片会导致之后需要分配较大对象时无法找到足够的连续内存而不得不提前触发一次垃圾收集动作</p><h4 id="标记整理算法-mark-compact" tabindex="-1"><a class="header-anchor" href="#标记整理算法-mark-compact" aria-hidden="true">#</a> 标记整理算法 Mark-Compact</h4><p>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存</p><figure><img src="'+I+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>适用于老年代，存活对象比较多的情形</p><p>缺点：移动存活对象操作极为负重</p><h3 id="评估" tabindex="-1"><a class="header-anchor" href="#评估" aria-hidden="true">#</a> 评估</h3><p>停顿时间 vs 吞吐量</p><h4 id="延迟-停顿时间" tabindex="-1"><a class="header-anchor" href="#延迟-停顿时间" aria-hidden="true">#</a> 延迟/停顿时间</h4><p>看单次影响 用户线程无法工作的时间</p><p>适用：与用户交互场景</p><p>经验：低于一秒的（即毫秒级别的）停顿时间用户是可以接受的</p><h4 id="吞吐量" tabindex="-1"><a class="header-anchor" href="#吞吐量" aria-hidden="true">#</a> 吞吐量</h4><p>看整体影响 CPU运行用户代码时间/CPU总消耗时间</p><p>其中，总消耗时间=CPU运行用户代码时间+垃圾收集时间 非用户程序时间：Compile Time, Class Load Time, GC Time</p><p>适用：后台运算场景</p><p>垃圾收集器组合</p><p>这些收集器里，面试的重点是两个——CMS和G1</p><p>新生代垃圾收集器都是标记复制算法（因为存活对象比较少） 老年代垃圾收集器，除了CMS是标记清除算法，Serial Old，Prallel Old，G1（新生代和老年代通用）都是标记整理算法</p><figure><img src="'+Q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>HotSpot虚拟机的垃圾收集器</p><p>Note：JDK9开始，Serial+CMS和ParNew+Serial Old两种组合被取消</p><p>什么是Stop the World：垃圾回收时，用户线程全部暂停 什么是SafePoint（安全点）：用户线程需要走到最近的安全点才可以暂停</p><figure><img src="'+Z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="选择方案" tabindex="-1"><a class="header-anchor" href="#选择方案" aria-hidden="true">#</a> 选择方案</h3><h4 id="选择一" tabindex="-1"><a class="header-anchor" href="#选择一" aria-hidden="true">#</a> 选择一</h4><p>特点：适用客户端，适合小内存</p><p>客户端模式下的默认垃圾收集器 <img src="'+Y+'" alt="" loading="lazy"></p><h5 id="serial" tabindex="-1"><a class="header-anchor" href="#serial" aria-hidden="true">#</a> Serial</h5><p>新生代，单线程，标记复制算法 只开启一条 GC 线程进行垃圾回收，并且在垃圾收集过程中停止一切用户线程(Stop The World)</p><figure><img src="'+$+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>避免线程切换开销，简单高效</p><p>适用内存较小的场景。客户端内存一般较小，适合客户端应用。</p><h5 id="serial-old" tabindex="-1"><a class="header-anchor" href="#serial-old" aria-hidden="true">#</a> Serial Old</h5><p>老年代，单线程，标记整理算法 Serial 的老年代版本，唯一的区别就是：Serial Old 工作在老年代，使用标记整理算法；Serial 工作在新生代，使用标记复制算法。</p><h4 id="选择二" tabindex="-1"><a class="header-anchor" href="#选择二" aria-hidden="true">#</a> 选择二</h4><p>特点：适用服务端，追求低停顿</p><h5 id="parnew" tabindex="-1"><a class="header-anchor" href="#parnew" aria-hidden="true">#</a> ParNew</h5><p>新生代，多线程，追求低停顿，标记复制算法 Serial的多线程版本，与 Serial 唯一区别就是使用了多线程进行垃圾收集</p><figure><img src="'+aa+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>追求低延迟/低停顿，适合交互式应用</p><p>单核CPU下，由于线程切换，性能不如Serial; 多核CPU下，性能比Serial好</p><p>只有它能与CMS收集器配合工作，所以它是不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器</p><p>ParNew收集器是激活CMS后（使用-XX：+UseConcMarkSweepGC选项）的默 认新生代收集器。JDK9开始，ParNew合并入CMS，成为它专门处理新生代的组成部 分</p><h5 id="cms-concurrent-mark-sweep-并发标记清除-称为-并发低停顿收集器" tabindex="-1"><a class="header-anchor" href="#cms-concurrent-mark-sweep-并发标记清除-称为-并发低停顿收集器" aria-hidden="true">#</a> CMS （Concurrent Mark Sweep，并发标记清除）（称为，并发低停顿收集器）</h5><p>老年代，多线程，追求低停顿，标记清除算法 追求低停顿，它在垃圾收集时使得用户线程和GC线程并发执行，因此在垃圾收集过程中用户也不会感到明显停顿</p><figure><img src="'+ea+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="过程" tabindex="-1"><a class="header-anchor" href="#过程" aria-hidden="true">#</a> 过程</h6><p>####### 初始标记 Stop The World，使用一条标记线程对所有与GC Roots直接关联的对象进行标记。速度很快。</p><p>####### 并发标记 使用多条标记线程，与用户线程并发执行。此过程从GC Roots的直接关联对象开始遍历整个对象图，进行可达性分析，标记出所有废弃对象。速度很慢。</p><p>####### 重新标记 Stop The World，使用多条标记线程，将上一步并发标记阶段新出现的废弃对象标记出来。速度很快，仅比初始标记慢一点。</p><p>####### 并发清除 使用一条GC线程，与用户线程并发执行，清除前两步所有标记出的废弃对象。这个过程非常耗时。</p><p>并发标记和并发清除过程耗时最长，但可以与用户线程一起工作，因此，总体上说，CMS的内存回收过程是与用户线程一起并发执行的</p><h6 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h6><p>吞吐量低</p><p>####### 无法处理浮动垃圾，且需要预留内存空间供用户线程分配新对象，所以没法等老年代几乎完全被填满再进行回收，而是老年代达到一定阈值就进行回收。JDK5默认68%，JDK6默认92% 在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p><p>参数-XX：CMSInitiatingOccupancyFraction用于设置这个阈值，用户应在生产环境中根据实际应用情况来权衡设置。 设置太低，触发回收的频率会增高。 设置太高将会很容易导致大量的并发失败产生，性能反而降低。</p><p>并发失败：要是CMS运行期间预留的内存无法满 足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。</p><p>使用标记清除算法产生大量碎片空间</p><h4 id="选择三" tabindex="-1"><a class="header-anchor" href="#选择三" aria-hidden="true">#</a> 选择三</h4><p>特点：适用服务端，追求高吞吐，自适应调节 <img src="'+ia+'" alt="" loading="lazy"></p><h5 id="parallel-scavenge-称为-吞吐量优先收集器" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge-称为-吞吐量优先收集器" aria-hidden="true">#</a> Parallel Scavenge （称为，吞吐量优先收集器）</h5><p>新生代，多线程，追求高吞吐，标记复制算法 追求高吞吐量，适合没有交互的后台计算</p><h6 id="配置" tabindex="-1"><a class="header-anchor" href="#配置" aria-hidden="true">#</a> 配置</h6><p>通过参数 -XX:GCTimeRadio 设置垃圾回收时间占总 CPU 时间的百分比。</p><p>通过参数 -XX:MaxGCPauseMillis 设置垃圾处理过程最久停顿时间。</p><p>通过命令 -XX:+UseAdaptiveSizePolicy 开启自适应调节策略。我们只要设置好堆的大小和MaxGCPauseMillis 或 GCTimeRadio，收集器会自动调整新生代的大小、Eden 和 Survivor 的比例、对象进入老年代的年龄，以最大程度上接近我们设置的 MaxGCPauseMillis 或 GCTimeRadio。</p><h5 id="parallel-old" tabindex="-1"><a class="header-anchor" href="#parallel-old" aria-hidden="true">#</a> Parallel Old</h5><p>老年代，多线程，追求高吞吐，标记整理算法 Parallel Scavenge 的老年代版本，追求 CPU 吞吐量</p><h4 id="选择四" tabindex="-1"><a class="header-anchor" href="#选择四" aria-hidden="true">#</a> 选择四</h4><p>特点：适用服务端，通用&amp;不分代，基于Region的堆内存布局，可以由用户指定期望的停顿时间(它默认的停顿目标为两百毫秒，通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的)，按收益动态确定回收集，目标是在延迟可控的情况下获得尽可能高的吞吐量</p><p>JDK9开始，成为服务端模式下的默认垃圾收集器</p><h5 id="g1-garbage-first-简称g1-称为-全功能垃圾收集器-fully-featured-garbage-collector" tabindex="-1"><a class="header-anchor" href="#g1-garbage-first-简称g1-称为-全功能垃圾收集器-fully-featured-garbage-collector" aria-hidden="true">#</a> G1 （Garbage First，简称G1）（称为，全功能垃圾收集器，Fully-Featured Garbage Collector）</h5><p>通用&amp;不分代，多线程，追求在延迟可控的情况下获得尽可能高的吞吐量，从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现 G1 是一款面向服务端应用的垃圾收集器</p><p>G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它并非纯粹地追求低延迟，官方给它设定的目标是“在延迟可控的情况下获得尽可能高的吞吐量“，所以才能担当起“全功能收集器”的重任与期望。设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡</p><p>G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存</p><p>缺：内存占用高</p><h6 id="g1开创了基于region的堆内存布局" tabindex="-1"><a class="header-anchor" href="#g1开创了基于region的堆内存布局" aria-hidden="true">#</a> G1开创了基于Region的堆内存布局</h6><p>（G1也仍是遵循分代收集理论） <img src="'+ra+'" alt="" loading="lazy"></p><p>把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理，</p><p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数 -XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</p><p>虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区 域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p><p>除了并发标记阶段与用户线程并发执行，其余阶段需Stop The World</p><figure><img src="'+na+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="_4个过程" tabindex="-1"><a class="header-anchor" href="#_4个过程" aria-hidden="true">#</a> 4个过程</h6><p>####### 初始标记 和CMS初始标记一致。Stop The World，使用一条标记线程对所有与GC Roots直接关联的对象进行标记。</p><p>####### 并发标记 和CMS并发标记一致。使用多条标记线程，与用户线程并发执行。此过程进行可达性分析，标记出所有废弃对象。速度很慢。</p><p>####### 最终标记 和CMS重新标记一致。Stop The World，使用多条标记线程，将上一步并发标记阶段新出现的废弃对象标记出来。</p><p>####### 筛选回收 Stop The World，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</p><p>这里抛个问题👇 一个对象和它内部所引用的对象可能不在同一个 Region 中，那么当垃圾回收时，是否需要扫描 整个堆内存才能完整地进行一次可达性分析？ 并不！每个 Region 都有一个 Remembered Set，用于记录本区域中所有对象引用的对象所在的区域，进行可达性分析时，只要在 GC Roots 中再加上 Remembered Set 即可防止对整个堆内存进行遍历。</p><h4 id="选择五" tabindex="-1"><a class="header-anchor" href="#选择五" aria-hidden="true">#</a> 选择五</h4><p>Parallel Scavenge</p><p>新生代，多线程，追求高吞吐</p><p>Serial Old</p><p>老年代，单线程，标记整理算法</p><h1 id="central-topic" tabindex="-1"><a class="header-anchor" href="#central-topic" aria-hidden="true">#</a> Central Topic</h1><p>Main Topic 1</p><p>Main Topic 2</p><p>Main Topic 3</p><p>Main Topic 4</p>',628),ha=[da];function ta(sa,oa){return i(),r("div",null,ha)}const ga=e(pa,[["render",ta],["__file","jvm.html.vue"]]);export{ga as default};
