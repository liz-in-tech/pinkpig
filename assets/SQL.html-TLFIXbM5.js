import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as i,o as d,c as o,a as e,b as a,e as s,f as n}from"./app-rvE1EVAc.js";const l={},c=n('<h1 id="sql" tabindex="-1"><a class="header-anchor" href="#sql" aria-hidden="true">#</a> SQL</h1><ul><li><a href="#sql">SQL</a></li><li><a href="#sql-1">SQL</a><ul><li><a href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2">关联查询</a></li><li><a href="#having%E4%B8%8Ewhere">having与where</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E4%B8%80%E5%88%97">添加一列</a></li><li><a href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">聚合函数</a></li><li><a href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0-%E6%B7%BB%E5%8A%A0%E6%8E%92%E5%90%8D%E5%88%97%E6%8E%92%E5%90%8Dtop-n">窗口函数-添加排名列(排名，top n)</a><ul><li><a href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0-%E5%85%B3%E9%94%AE%E5%AD%97overpartitionorder">窗口函数 关键字：over,partition,order</a></li><li><a href="#%E6%8E%92%E5%90%8D-rankdense_rankrow_number">排名 rank,dense_rank,row_number</a></li><li><a href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0">聚合函数作为窗口函数</a></li></ul></li><li><a href="#%E9%A1%BA%E5%BA%8F">顺序</a></li><li><a href="#%E5%8E%BB%E9%87%8Ddistinct">去重distinct</a></li><li><a href="#%E5%8C%85%E5%90%ABin">包含in</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86">字符串处理</a><ul><li><a href="#%E5%AD%90%E4%B8%B2-substrstrstart-------substrstrstartlen">子串 substr(str,start) | substr(str,start,len)</a></li><li><a href="#%E5%AD%90%E4%B8%B2-leftstrlen---rightstrlen">子串 left(str,len) | right(str,len)</a></li><li><a href="#%E5%8F%8D%E8%BD%AC-reversestr">反转 reverse(str)</a></li><li><a href="#%E6%8B%BC%E6%8E%A5-concat">拼接 concat</a></li></ul></li><li><a href="#%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86">时间处理</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%B7%AE-timestampdiff%E8%AE%A1%E7%AE%97%E7%B2%92%E5%BA%A6%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4%E7%BB%93%E6%9D%9F%E6%97%B6%E9%97%B4">计算时间差 timestampdiff(计算粒度,开始时间,结束时间)</a></li></ul></li><li><a href="#%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E4%B8%8E%E5%8F%96%E6%95%B4">四舍五入与取整</a></li></ul></li><li><a href="#other">other</a><ul><li><a href="#1distinct%E5%85%B3%E9%94%AE%E5%AD%97%E5%BF%85%E9%A1%BB%E7%9B%B4%E6%8E%A5%E6%94%BE%E5%9C%A8%E5%88%97%E5%90%8D%E7%9A%84%E5%89%8D%E9%9D%A2%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8%E4%BA%8E%E6%89%80%E6%9C%89%E8%A6%81%E6%9F%A5%E7%9A%84%E5%88%97-">1.Distinct关键字（必须直接放在列名的前面；关键字作用于所有要查的列） </a></li><li><a href="#2%E8%A1%8C%E6%95%B0%E9%99%90%E5%88%B6-">2.行数限制： </a></li><li><a href="#3%E6%B3%A8%E9%87%8A-">3. 注释 </a></li><li><a href="#4%E6%8E%92%E5%BA%8F-">4. 排序 </a></li><li><a href="#5where-">5. Where </a></li><li><a href="#6%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%9D%A5%E5%8C%B9%E9%85%8D%E5%80%BC%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6-">6. 通配符（用来匹配值的一部分的特殊字符） </a></li><li><a href="#7%E6%8B%BC%E6%8E%A5%E5%AD%97%E6%AE%B5-">7. 拼接字段 </a></li><li><a href="#8%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0-">8. 聚集函数 </a></li><li><a href="#9%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE-">9.分组数据 </a></li><li><a href="#10select%E5%AD%90%E5%8F%A5%E5%8F%8A%E5%85%B6%E9%A1%BA%E5%BA%8F-">10.Select子句及其顺序 </a></li><li><a href="#11%E5%AD%90%E6%9F%A5%E8%AF%A2note%E4%BD%9C%E4%B8%BA%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84select%E8%AF%AD%E5%8F%A5%E5%8F%AA%E8%83%BD%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E5%88%97%E4%BC%81%E5%9B%BE%E6%A3%80%E7%B4%A2%E5%A4%9A%E4%B8%AA%E5%88%97%E5%B0%86%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%B8%B8%E7%94%A8%E4%BA%8Ewhere%E5%AD%90%E5%8F%A5%E7%9A%84in%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%AD-">11.子查询（NOTE:作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误。子查询常用于where子句的in操作符中） </a></li><li><a href="#12%E8%81%94%E7%BB%93%E8%81%94%E7%BB%93%E6%98%AF%E4%B8%80%E7%A7%8D%E6%9C%BA%E5%88%B6%E7%94%A8%E6%9D%A5%E5%9C%A8%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%E4%B8%AD%E5%85%B3%E8%81%94%E8%A1%A8%E5%9B%A0%E6%AD%A4%E7%A7%B0%E4%B8%BA%E8%81%94%E7%BB%93-">12. 联结（联结是一种机制，用来在一条select语句中关联表，因此称为联结） </a></li><li><a href="#13%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8union%E5%BE%88%E7%AE%80%E5%8D%95%E6%89%80%E8%A6%81%E5%81%9A%E7%9A%84%E5%8F%AA%E6%98%AF%E7%BB%99%E5%87%BA%E6%AF%8F%E6%9D%A1select%E8%AF%AD%E5%8F%A5%E5%9C%A8%E5%90%84%E6%9D%A1%E8%AF%AD%E5%8F%A5%E4%B9%8B%E9%97%B4%E6%94%BE%E4%B8%8A%E5%85%B3%E9%94%AE%E5%AD%97union-">13. 组合查询（使用union很简单，所要做的只是给出每条select语句，在各条语句之间放上关键字union） </a></li><li><a href="#14%E8%A7%86%E5%9B%BE-">14. 视图 </a></li><li><a href="#15-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-">15. 存储过程 </a></li></ul></li></ul><h1 id="sql-1" tabindex="-1"><a class="header-anchor" href="#sql-1" aria-hidden="true">#</a> SQL</h1><h2 id="关联查询" tabindex="-1"><a class="header-anchor" href="#关联查询" aria-hidden="true">#</a> 关联查询</h2><p>select * from tb1 left join tb2 on tb1.id = tb2.id; <br></p><h2 id="having与where" tabindex="-1"><a class="header-anchor" href="#having与where" aria-hidden="true">#</a> having与where</h2>',6),u=e("br",null,null,-1),h=e("strong",null,"having与where的区别:",-1),E=e("br",null,null,-1),p=e("br",null,null,-1),b=e("br",null,null,-1),m={href:"https://so.csdn.net/so/search?q=%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},A=e("br",null,null,-1),_=e("br",null,null,-1),v=n(`<h2 id="添加一列" tabindex="-1"><a class="header-anchor" href="#添加一列" aria-hidden="true">#</a> 添加一列</h2><p>1、固定值/表达式 as new_col <br> select (normal_salary - dock_salary) as salary from salary_tb; <br> select &#39;Male&#39; as gender from users; <br> 2、分条件 <br> case <br> when 条件1 then 值1 <br> when 条件2 then 值2 <br> else 值3 <br> end <br> as new_col <br></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token constant">SELECT</span>
<span class="token constant">CASE</span>
    <span class="token class-name">WHEN</span> gender <span class="token operator">=</span> <span class="token number">1</span> <span class="token constant">THEN</span> <span class="token char">&#39;Male&#39;</span>
    <span class="token class-name">WHEN</span> gender <span class="token operator">=</span> <span class="token number">2</span> <span class="token constant">THEN</span> <span class="token char">&#39;Female&#39;</span>
<span class="token constant">END</span>
as gender from users<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token constant">SELECT</span>
<span class="token constant">CASE</span> 
    <span class="token constant">WHEN</span> age <span class="token operator">&lt;</span> <span class="token number">18</span> <span class="token constant">THEN</span> <span class="token char">&#39;Child&#39;</span>
    <span class="token constant">WHEN</span> age <span class="token operator">&gt;=</span> <span class="token number">18</span> <span class="token constant">AND</span> age <span class="token operator">&lt;=</span> <span class="token number">50</span> <span class="token constant">THEN</span> <span class="token char">&#39;Adult&#39;</span>
    <span class="token constant">ELSE</span> <span class="token char">&#39;Elder&#39;</span>
<span class="token constant">END</span>
as age_category from users<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="聚合函数" tabindex="-1"><a class="header-anchor" href="#聚合函数" aria-hidden="true">#</a> 聚合函数</h2><p>平均值函数avg <br> 求和 sum <br> 最大值 max <br> 最小值 min <br> 基数 count <br></p><h2 id="窗口函数-添加排名列-排名-top-n" tabindex="-1"><a class="header-anchor" href="#窗口函数-添加排名列-排名-top-n" aria-hidden="true">#</a> 窗口函数-添加排名列(排名，top n)</h2>`,7),f={href:"https://www.zhihu.com/tardis/bd/art/92654574?source_id=1001",target:"_blank",rel:"noopener noreferrer"},B=e("br",null,null,-1),k=n(`<h3 id="窗口函数-关键字-over-partition-order" tabindex="-1"><a class="header-anchor" href="#窗口函数-关键字-over-partition-order" aria-hidden="true">#</a> 窗口函数 关键字：over,partition,order</h3><p>1）同时具有分组和排序的功能 <br> 2）不减少原表的行数 <br> 3）语法如下： <br></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt;
                order by &lt;用于排序的列名&gt;)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="排名-rank-dense-rank-row-number" tabindex="-1"><a class="header-anchor" href="#排名-rank-dense-rank-row-number" aria-hidden="true">#</a> 排名 rank,dense_rank,row_number</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">select</span> *,
   rank<span class="token punctuation">(</span><span class="token punctuation">)</span> over <span class="token punctuation">(</span>order by 成绩 desc<span class="token punctuation">)</span> as ranking
from 班级表
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">select</span> *,
   rank<span class="token punctuation">(</span><span class="token punctuation">)</span> over <span class="token punctuation">(</span>order by 成绩 desc<span class="token punctuation">)</span> as ranking,
   dense_rank<span class="token punctuation">(</span><span class="token punctuation">)</span> over <span class="token punctuation">(</span>order by 成绩 desc<span class="token punctuation">)</span> as dese_rank,
   row_number<span class="token punctuation">(</span><span class="token punctuation">)</span> over <span class="token punctuation">(</span>order by 成绩 desc<span class="token punctuation">)</span> as row_num
from 班级表
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="聚合函数作为窗口函数" tabindex="-1"><a class="header-anchor" href="#聚合函数作为窗口函数" aria-hidden="true">#</a> 聚合函数作为窗口函数</h3><p>聚合函数作为窗口函数，可以在每一行的数据里直观的看到，截止到本行数据，统计数据是多少（最大值、最小值等）。同时可以看出每一行数据，对整体统计数据的影响。 <br></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">select</span> *,
   sum<span class="token punctuation">(</span>成绩<span class="token punctuation">)</span> over <span class="token punctuation">(</span>order by 学号<span class="token punctuation">)</span> as current_sum,
   avg<span class="token punctuation">(</span>成绩<span class="token punctuation">)</span> over <span class="token punctuation">(</span>order by 学号<span class="token punctuation">)</span> as current_avg,
   count<span class="token punctuation">(</span>成绩<span class="token punctuation">)</span> over <span class="token punctuation">(</span>order by 学号<span class="token punctuation">)</span> as current_count,
   max<span class="token punctuation">(</span>成绩<span class="token punctuation">)</span> over <span class="token punctuation">(</span>order by 学号<span class="token punctuation">)</span> as current_max,
   min<span class="token punctuation">(</span>成绩<span class="token punctuation">)</span> over <span class="token punctuation">(</span>order by 学号<span class="token punctuation">)</span> as current_min
from 班级表
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="顺序" tabindex="-1"><a class="header-anchor" href="#顺序" aria-hidden="true">#</a> 顺序</h2><p>先条件筛选 where <br> 后分组 group by 列 <br> 再排序 order by 列 desc <br></p><h2 id="去重distinct" tabindex="-1"><a class="header-anchor" href="#去重distinct" aria-hidden="true">#</a> 去重distinct</h2><p>select distinct user_id from order_tb where order_time like &quot;2022-09-02%&quot;; <br></p><h2 id="包含in" tabindex="-1"><a class="header-anchor" href="#包含in" aria-hidden="true">#</a> 包含in</h2><p>where user_id in (select distinct user_id from order_tb where order_time like &quot;2022-09-02%&quot;) <br></p><h2 id="字符串处理" tabindex="-1"><a class="header-anchor" href="#字符串处理" aria-hidden="true">#</a> 字符串处理</h2>`,16),g={href:"https://blog.csdn.net/weixin_62360479/article/details/127996907",target:"_blank",rel:"noopener noreferrer"},D=e("br",null,null,-1),w=n(`<h3 id="子串-substr-str-start-substr-str-start-len" tabindex="-1"><a class="header-anchor" href="#子串-substr-str-start-substr-str-start-len" aria-hidden="true">#</a> 子串 substr(str,start) | substr(str,start,len)</h3><h3 id="子串-left-str-len-right-str-len" tabindex="-1"><a class="header-anchor" href="#子串-left-str-len-right-str-len" aria-hidden="true">#</a> 子串 left(str,len) | right(str,len)</h3><p>select *,left(order_time,10) as order_date from order_tb; <br></p><h3 id="反转-reverse-str" tabindex="-1"><a class="header-anchor" href="#反转-reverse-str" aria-hidden="true">#</a> 反转 reverse(str)</h3><h3 id="拼接-concat" tabindex="-1"><a class="header-anchor" href="#拼接-concat" aria-hidden="true">#</a> 拼接 concat</h3><h2 id="时间处理" tabindex="-1"><a class="header-anchor" href="#时间处理" aria-hidden="true">#</a> 时间处理</h2><h3 id="计算时间差-timestampdiff-计算粒度-开始时间-结束时间" tabindex="-1"><a class="header-anchor" href="#计算时间差-timestampdiff-计算粒度-开始时间-结束时间" aria-hidden="true">#</a> 计算时间差 timestampdiff(计算粒度,开始时间,结束时间)</h3><p>timestampdiff()函数：用于计算两个日期或时间之间的时间差。 <br> Note：以下的大写均可小写 <br> 例如：SELECT TIMESTAMPDIFF(MINUTE, &#39;2021-08-15 12:30:00&#39;, &#39;2021-08-15 12:45:00&#39;); 结果为 15，表示两个时间之间相差 15 分钟。 <br> 在使用 TIMESTAMPDIFF() 函数时，第一个参数可以是 YEAR、MONTH、DAY、HOUR、MINUTE、SECOND 、QUARTER（季）、WEEK（周）等。 <br></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">select</span>
	tb.logtime as order_time,
  tb1.logtime as pay_time,
  timestampdiff<span class="token punctuation">(</span>second,tb.logtime,tb1.logtime<span class="token punctuation">)</span> as gap
from order_log as tb inner <span class="token function">join</span> select_log as tb1 on tb.order_id <span class="token operator">=</span> tb1.order_id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="四舍五入与取整" tabindex="-1"><a class="header-anchor" href="#四舍五入与取整" aria-hidden="true">#</a> 四舍五入与取整</h2><p>round(值,2) 第2个参数指取几位小数 <br> 取整： <br> round(值，0) <br> floor(值) <br> ceiling(值) <br></p><h1 id="other" tabindex="-1"><a class="header-anchor" href="#other" aria-hidden="true">#</a> other</h1><p>数据库（文件柜） <br> 数据库软件：数据库管理系统（DBMS） <br> 数据库是通过DBMS创建和操纵的容器，而具体它究竟是什么，形式如何，各种数据库都不一样。 <br></p><h2 id="_1-distinct关键字-必须直接放在列名的前面-关键字作用于所有要查的列" tabindex="-1"><a class="header-anchor" href="#_1-distinct关键字-必须直接放在列名的前面-关键字作用于所有要查的列" aria-hidden="true">#</a> 1.Distinct关键字（必须直接放在列名的前面；关键字作用于所有要查的列） <br></h2><h2 id="_2-行数限制" tabindex="-1"><a class="header-anchor" href="#_2-行数限制" aria-hidden="true">#</a> 2.行数限制： <br></h2><p>Mysql（需要使用LIMIT子句） <br> select prod_name from Products limit 4; <br> select prod_name from Products limit 4 offset 3;(第一个数字：检索的行数；第二个数字：从哪开始，从0开始) <br> select prod_name from Products limit 3,4; <br> Oracle（需要基于ROWNUM行计数器来计算行）select prod_name from Products where rownum &lt;= 5; <br></p><h2 id="_3-注释" tabindex="-1"><a class="header-anchor" href="#_3-注释" aria-hidden="true">#</a> 3. 注释 <br></h2><p>--单行 <br> /<em>多行</em>/ <br></p><h2 id="_4-排序" tabindex="-1"><a class="header-anchor" href="#_4-排序" aria-hidden="true">#</a> 4. 排序 <br></h2><p>Order by prod_price desc,prod_name; <br> Order by位于where之后 <br></p><h2 id="_5-where" tabindex="-1"><a class="header-anchor" href="#_5-where" aria-hidden="true">#</a> 5. Where <br></h2><p>1）Between操作符（必须指定两个值——所需范围的低端值和高端值，这两个值必须用and分隔，between匹配范围包括开始值和结束值）：select prod_name,prod_price from Products where prod_price between 5 and 10; <br> 2）is null <br> 3）or(匹配任一条件) <br> And和or组合使用：and优先级高于or（用圆括号消除歧义） <br> 4）in（指定条件范围，范围中的每个条件都可以进行匹配；由逗号分隔，括在圆括号中） <br> In的最大优点是可以包含其他select语句 <br> 5）not(where子句中用来否定其后条件的关键字) <br> Select prod_name from products where not vend_id = ‘DLL01’ order by prod_name; <br></p><h2 id="_6-通配符-用来匹配值的一部分的特殊字符" tabindex="-1"><a class="header-anchor" href="#_6-通配符-用来匹配值的一部分的特殊字符" aria-hidden="true">#</a> 6. 通配符（用来匹配值的一部分的特殊字符） <br></h2><p>为在搜索子句中使用通配符，必须使用like操作符 <br> 通配符搜索只能用于文本字段，非文本数据类型字段不能使用通配符搜索。 <br> A. 百分号（%）通配符：任何字符出现任意次数，可在任意位置使用，并且可以使用多个通配符。除了能匹配一个或多个字符外，%还能匹配0个字符。通配符%不能匹配null,子句where prod_name like ‘%’不会匹配产品名称为null的行。 <br> B. 下划线（_）通配符：只匹配单个字符，而不是多个字符 <br></p><h2 id="_7-拼接字段" tabindex="-1"><a class="header-anchor" href="#_7-拼接字段" aria-hidden="true">#</a> 7. 拼接字段 <br></h2><p>使用||拼接两个列 <br> Select vend_name || ‘ (’ || vend_country || ‘)’ from Vendors order by vend_name; <br> 许多数据库（不是所有）保存填充为列宽的文本值，而实际上你要的结果不需要这些空格。这可以使用SQL的RTRIM()函数来完成。 <br> Select RTRIM(vend_name) || ‘ (’ || RTRIM(vend_country) || ‘)’ AS vend_title from Vendors order by vend_name; <br> NOTE:TRIM函数 <br> RTRIM（去掉字符串右边的空格） <br> LTRIM（去掉字符串左边的空格） <br> TRIM（去掉字符串左右两边的空格） <br></p><h2 id="_8-聚集函数" tabindex="-1"><a class="header-anchor" href="#_8-聚集函数" aria-hidden="true">#</a> 8. 聚集函数 <br></h2><p>AVG()   注意：只用于单个列，为了获得多个列的平均值，必须使用多个此函数。AVG()函数忽略列值为null的行。AVG(DISTINCT  column)只包含不同的值，指定DISTINCT参数。 <br> COUNT()  两种方式：COUNT(*)不管表列中是否包含空值；COUNT(column)忽略null值。 <br> MAX()   MAX()函数忽略列值为null的行。 <br> MIN()   MIN()函数忽略列值为null的行。 <br> SUM()  SUM()函数忽略列值为null的行。SUM(DISTINCT  column)只包含不同的值，指定DISTINCT参数。 <br></p><h2 id="_9-分组数据" tabindex="-1"><a class="header-anchor" href="#_9-分组数据" aria-hidden="true">#</a> 9.分组数据 <br></h2><p>GROUP BY子句 <br> GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在select中使用表达式，则必须在GROUP BY子句中指定相同的表达式，不能使用别名。除聚集计算语句外，select语句中的每一列都必须在GROUP BY子句中给出。 <br> HAVING子句：过滤分组（WHERE过滤行，而HAVING过滤分组。HAVING支持所有WHERE操作符） <br> 例：列出具有两个以上产品且其价格大于等于4的供应商 <br> Select vend_id,count(<em>) as num_prods from Products where prod_price &gt;= 4  group by vend_id having count(</em>) &gt;= 2; <br> (where子句过滤所有prod_price至少为4的行，然后按vend_id分组数据，having子句过滤计数为2或2以上的分组) <br> 例：检索包含3个或更多物品的订单号和订购物品的数目，要按订购物品的数目排序输出 <br> Select order_num,count(<em>) as items from OrderItems group by order_num having count(</em>) &gt;= 3 order by items,order_num; <br></p><h2 id="_10-select子句及其顺序" tabindex="-1"><a class="header-anchor" href="#_10-select子句及其顺序" aria-hidden="true">#</a> 10.Select子句及其顺序 <br></h2><p>Select <br> From <br> Where <br> Group by <br> Having <br> Order by <br></p><h2 id="_11-子查询-note-作为子查询的select语句只能查询单个列。企图检索多个列将返回错误。子查询常用于where子句的in操作符中" tabindex="-1"><a class="header-anchor" href="#_11-子查询-note-作为子查询的select语句只能查询单个列。企图检索多个列将返回错误。子查询常用于where子句的in操作符中" aria-hidden="true">#</a> 11.子查询（NOTE:作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误。子查询常用于where子句的in操作符中） <br></h2><p>Select cust_name,cust_contact from Customers where cust_id in(select cust_id from Order where order_num in (select order_num from OrderItems where prod_id = ‘RGAN01’)); <br></p><h2 id="_12-联结-联结是一种机制-用来在一条select语句中关联表-因此称为联结" tabindex="-1"><a class="header-anchor" href="#_12-联结-联结是一种机制-用来在一条select语句中关联表-因此称为联结" aria-hidden="true">#</a> 12. 联结（联结是一种机制，用来在一条select语句中关联表，因此称为联结） <br></h2><p>Select vend_name,prod_name,prod_price from Vendors,Products where Vendors.vend_id = Products.vend_id; <br> 内联结：等值联结，它基于两个表之间的相等测试。 <br> Select vend_name.prod_name,prod_price from Venders inner join Products on Vendors.vend_id = Products.vend_id; <br> 外联结：(外联结还包括没有关联行的行，在使用outer join语法时，必须使用right或left关键字指定包括其所有行的表) <br> 对每个顾客下的订单进行计数，包括哪些至今尚未下订单的顾客； <br> 列出所有产品以及订购数量，包括没有人订购的产品； <br> 计算平均销售规模，包括那些至今尚未下订单的顾客 <br> Select Customers.cust_id,Orders.order_num from Customers left outer join Orders on Customers.cust_id = Orders.cust_id; <br> 全外联结：它检索两个表中的所有行并关联那些可以关联的行。 <br> Select Customers.cust_id,Orders.order_num from Orders full outer join Customers on Orders.cust_id = Customers.cust_id; <br></p><h2 id="_13-组合查询-使用union很简单-所要做的只是给出每条select语句-在各条语句之间放上关键字union" tabindex="-1"><a class="header-anchor" href="#_13-组合查询-使用union很简单-所要做的只是给出每条select语句-在各条语句之间放上关键字union" aria-hidden="true">#</a> 13. 组合查询（使用union很简单，所要做的只是给出每条select语句，在各条语句之间放上关键字union） <br></h2><p>Select cust_name,cust_contact,cust_email from Customers where cust_state in(‘IL’,’IN’,’MI’) <br> union <br> Select cust_name,cust_contact,cust_email from Customers where cust_name = ‘Fun4All’; <br> 如果组合四条select语句，将要使用三个union关键字。 <br> Union中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出） <br> Union从查询结果集中自动去除了重复的行，如果不用去除重复行，可使用union all. <br> 在用union组合查询时，只能使用一条order by子句，它必须位于最后一条select语句之后，它对返回的所有结果排序。 <br> Select cust_name,cust_contact,cust_email from Customers where cust_state in(‘IL’,’IN’,’MI’) <br> union <br> Select cust_name,cust_contact,cust_email from Customers where cust_name = ‘Fun4All’ order by cust_name,cust_contact; <br></p><h2 id="_14-视图" tabindex="-1"><a class="header-anchor" href="#_14-视图" aria-hidden="true">#</a> 14. 视图 <br></h2><p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。 <br> 把整个查询包装成一个名为ProductCustomers的虚拟表，则可以如下轻松的检索出相同的数据。Select cust_name,cust_contact from ProductCustomers where prod_id = ‘RGAN01’; <br></p><p>创建视图 <br> Create view ProductCustomers as select cust_name.cust_contact,prod_id from Customers,Orders,OrderItems where Customers.cust_id = Orders.cust_id and OrderItems.order_num = Orders.order_num; <br> 可一次性编写基础的SQL,然后根据需要多次使用。 <br> 视图提供了一种封装select语句的层次，可用来简化数据处理，重新格式化或保护基础数据。 <br></p><h2 id="_15-存储过程" tabindex="-1"><a class="header-anchor" href="#_15-存储过程" aria-hidden="true">#</a> 15. 存储过程 <br></h2><p>存储过程就是为以后使用而保存的一条或多条SQL语句。可将其视为批文件，虽然它们的作用不仅限于批处理。使用存储过程有三个主要的好处，即简单、安全、高性能。 <br> 例： <br> 为了处理订单，必须核对以保证库存中有相应的物品。 <br> 如果物品有库存，需要预定，不再出售给别的人，并且减少物品数据以反映正确的库存量。 <br> 库存中没有的物品需要订购，这需要与供应商进行某种交互。 <br> 关于哪些物品入库（并且可以立即发货）和哪些物品退订，需要通知相应的顾客。 <br> 1）执行存储过程 <br> 执行存储过程的SQL语句很简单，即execute. <br> Execute接受存储过程名和需要传递给它的任何参数。 <br> 例：execute AddNewProduct(‘JTS01’,’Stuffed Eiffel Tower’,6.49,’Plush stuffed toy with the text La Tour Eiffel in red white and Blue’); <br> 2）创建存储过程 <br></p>`,43);function x(C,F){const r=i("ExternalLinkIcon");return d(),o("div",null,[c,e("p",null,[a("having子句与where都是设定条件筛选的语句，有相似之处也有区别。 "),u,h,a(),E,a(" having是在分组后对数据进行过滤 "),p,a(" where是在分组前对数据进行过滤 "),b,a(" having后面可以使用"),e("a",m,[a("聚合函数"),s(r)]),a(),A,a(" where后面不可以使用聚合 "),_]),v,e("p",null,[e("a",f,[a("窗口函数介绍"),s(r)]),a(),B]),k,e("p",null,[e("a",g,[a("字符串处理大全"),s(r)]),a(),D]),w])}const I=t(l,[["render",x],["__file","SQL.html.vue"]]);export{I as default};
