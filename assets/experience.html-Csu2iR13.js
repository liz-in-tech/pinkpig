import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as n,f as s}from"./app-EOZBWKNC.js";const i="/pinkpig/assets/experience_001-_nr_G4nc.png",t="/pinkpig/assets/experience_002-zxREz1O-.png",l="/pinkpig/assets/experience_003-2qDHOArN.png",r="/pinkpig/assets/github_opensource-7876A7zY.png",d="/pinkpig/assets/github_opensource_pr-znGQ_3HU.png",c={},o=s('<h1 id="经验积累" tabindex="-1"><a class="header-anchor" href="#经验积累" aria-hidden="true">#</a> 经验积累</h1><h2 id="_1-如何看源码" tabindex="-1"><a class="header-anchor" href="#_1-如何看源码" aria-hidden="true">#</a> 1. 如何看源码</h2><h3 id="_1-1-第一步-有一个示例代码" tabindex="-1"><a class="header-anchor" href="#_1-1-第一步-有一个示例代码" aria-hidden="true">#</a> 1.1. 第一步：有一个示例代码</h3><p>方式一：找源码里的test</p><p>方式二：让AI帮忙写用于看源码的简单示例代码</p><h3 id="_1-2-第二步-找到源码入口" tabindex="-1"><a class="header-anchor" href="#_1-2-第二步-找到源码入口" aria-hidden="true">#</a> 1.2. 第二步：找到源码入口</h3><p>先找到入口，切记，入口只有一个</p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>哪里是入口？run方法，直接能跑起来的地方 Note：如果从第一行代码作为入口看，那要看死自己啊</p><h3 id="_1-3-第三步-从入口看下去" tabindex="-1"><a class="header-anchor" href="#_1-3-第三步-从入口看下去" aria-hidden="true">#</a> 1.3. 第三步：从入口看下去</h3><h4 id="_1-3-1-step1-直接去llmchain找run方法-没找到" tabindex="-1"><a class="header-anchor" href="#_1-3-1-step1-直接去llmchain找run方法-没找到" aria-hidden="true">#</a> 1.3.1. Step1：直接去LLMChain找run方法-&gt;没找到</h4><p>第一反应该怎么办？答：看有没有父类</p><p>方法论： 不管什么框架，其结构一定都是：接口-&gt;抽象类-&gt;实现类。接口定义模式，抽象类定义流程，实现类定义逻辑。</p><p>大部分框架源码用到了模板方法，装饰器，代理，工厂，单例这几个设计模式</p><p>不推荐大家打断点去调试</p><h4 id="_1-3-2-step2-在父类chain里找到了run方法-有很多if判断后抛异常的直接忽略不用看-直接看真正做实事的-提高效率" tabindex="-1"><a class="header-anchor" href="#_1-3-2-step2-在父类chain里找到了run方法-有很多if判断后抛异常的直接忽略不用看-直接看真正做实事的-提高效率" aria-hidden="true">#</a> 1.3.2. Step2：在父类Chain里找到了run方法-&gt;有很多if判断后抛异常的直接忽略不用看，直接看真正做实事的，提高效率</h4><h4 id="_1-3-3-step3-代码chain-run-colorful-socks-有一个参数-所以只有图中标蓝的那一行代码需要看" tabindex="-1"><a class="header-anchor" href="#_1-3-3-step3-代码chain-run-colorful-socks-有一个参数-所以只有图中标蓝的那一行代码需要看" aria-hidden="true">#</a> 1.3.3. Step3：代码chain.run(&quot;colorful socks&quot;)有一个参数，所以只有图中标蓝的那一行代码需要看</h4><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个语法是python的新特性，self()直接会调用__call__函数，这是一个约定</p><h4 id="_1-3-4-step4-看-call-函数" tabindex="-1"><a class="header-anchor" href="#_1-3-4-step4-看-call-函数" aria-hidden="true">#</a> 1.3.4. Step4：看__call__函数</h4><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>开源框架里的注释一定要多看</p><p>特殊场景的跳过，只看通用场景</p><h2 id="_2-如何贡献开源代码" tabindex="-1"><a class="header-anchor" href="#_2-如何贡献开源代码" aria-hidden="true">#</a> 2. 如何贡献开源代码</h2><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-1-step1-找要贡献的内容-fix-or-feature" tabindex="-1"><a class="header-anchor" href="#_2-1-step1-找要贡献的内容-fix-or-feature" aria-hidden="true">#</a> 2.1. Step1：找要贡献的内容（fix or feature）</h3><ul><li>找issue，把issue分配assign给自己</li><li>自己发现bug，创建issue，把issue分配assign给自己</li><li>不关联issue，直接进行下一步</li><li>看技术路线图roadmap，找自己可参与的feature</li></ul><p>筛选issue</p><ul><li>&quot;-linked:pr&quot;用于过滤掉已关联PR的issue</li><li>&quot;label:&quot;area: agent&quot;&quot;用于按标签缩小范围</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>is:issue is:open -linked:pr label:&quot;area: agent&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_2-2-step2-fork代码到个人github仓库-然后clone个人的该项目到本地" tabindex="-1"><a class="header-anchor" href="#_2-2-step2-fork代码到个人github仓库-然后clone个人的该项目到本地" aria-hidden="true">#</a> 2.2. Step2：fork代码到个人Github仓库，然后clone个人的该项目到本地</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git clone xxx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_2-3-step3-在本地创建新分支-在新分支上改代码写单测-格式化代码-format-lint-进行功能测试" tabindex="-1"><a class="header-anchor" href="#_2-3-step3-在本地创建新分支-在新分支上改代码写单测-格式化代码-format-lint-进行功能测试" aria-hidden="true">#</a> 2.3. Step3：在本地创建新分支，在新分支上改代码写单测，格式化代码 format/lint，进行功能测试</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># Note：分支名命名最好能体现本次的贡献代码的内容
git checkout -b fix-xxx-bug
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-step4-add-commit-push" tabindex="-1"><a class="header-anchor" href="#_2-4-step4-add-commit-push" aria-hidden="true">#</a> 2.4. Step4：add + commit + push</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git add .

# Note：commit内容要更具体体现本次的贡献代码的内容
git commit -m &quot;xxx&quot;

# Note：以新创建的分支提交到远程个人Github仓库
git push origin fix-xxx-bug
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-5-step5-创建pr-pull-request" tabindex="-1"><a class="header-anchor" href="#_2-5-step5-创建pr-pull-request" aria-hidden="true">#</a> 2.5. Step5：创建PR (Pull Request)</h3><ul><li>进入你的 fork 版本的 GitHub 仓库</li><li>你会看到一个“Compare &amp; pull request” 按钮，点击它</li><li>添加描述，说明你的修改</li><li>提交 PR，等待维护者审核和合并</li><li>维护者可能会要求你修改一些内容，记得关注你的 PR 哦</li></ul><h2 id="_3-代码经验积累" tabindex="-1"><a class="header-anchor" href="#_3-代码经验积累" aria-hidden="true">#</a> 3. 代码经验积累</h2><h3 id="_3-1-verbose" tabindex="-1"><a class="header-anchor" href="#_3-1-verbose" aria-hidden="true">#</a> 3.1. verbose</h3><p>这个词源自英文单词 &quot;verbose&quot;, 意味着 &quot;啰嗦的&quot; 或 &quot;详细的”，当verbose设置为True时，程序会输出更多的信息，在开发调试阶段，可以帮助开发者了解程序的内部运行情况</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>verbose: bool = True
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_3-2-对象作为函数-call-方法" tabindex="-1"><a class="header-anchor" href="#_3-2-对象作为函数-call-方法" aria-hidden="true">#</a> 3.2. 对象作为函数:__call__方法</h3><ul><li>在 Python 中，实例可以表现得像一个函数，这是通过定义类的__call__方法实现的。当一个类定义了 __call__方法时，其实例可以被像普通函数那样调用。这种技术通常用于创建行为类似于函数的对象，同时又保持了类实例的状态和方法。</li><li>__call__方法允许一个类的实例表现得像一个函数</li><li>当尝试像调用函数一样调用一个对象时，Python会自动调用该对象的__call__方法</li></ul><p>示例</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Adder</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>n <span class="token operator">=</span> n

    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>n <span class="token operator">+</span> x

<span class="token comment"># 创建一个Adder类的实例</span>
adder <span class="token operator">=</span> Adder<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>

<span class="token comment"># 由于Adder类定义了__call__方法，所以可以像函数一样调用其实例</span>
result <span class="token operator">=</span> adder<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment"># 相当于调用 adder.__call__(10)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment"># 输出15</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,47),p=[o];function u(h,_){return a(),n("div",null,p)}const b=e(c,[["render",u],["__file","experience.html.vue"]]);export{b as default};
