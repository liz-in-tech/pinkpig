import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as r,c as a,f as t}from"./app-LpUjRToi.js";const d={},n=t('<h1 id="队列" tabindex="-1"><a class="header-anchor" href="#队列" aria-hidden="true">#</a> 队列</h1><p>（1）队列也是一种“操作受限”的线性表，只支持两种基本操作：入队（队尾）和出队 （队头） <br> （2）顺序队列和链式队列 <br> 顺序队列：用数组实现 <br> 针对队尾满了，对头还有很多空位，解决方案：循环队列；一旦队尾满了，整体移到前面（不如循环队列） <br> 链式队列：用链表实现 <br> （3）循环队列 <br> 要想写出没有 bug 的循环队列实现代码，关键要确定好队空和队满的判定条件。 <br> 队满判定条件：head=tail <br> 队满判定条件：(tail+1)%n=head <br> （4）阻塞队列与并发队列 <br> 阻塞队列、并发队列，底层都还是队列这种数 据结构，只不过在之上附加了很多其他功能。阻塞队列就是入队、出队操作可以阻塞，并发 队列就是队列的操作多线程安全。 <br> （5）应用 <br> 算法中应用：广度优先搜索 <br></p><p>队列的应用非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。 它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。 <br> 队列在线程池等有限资源池中的应用 <br> CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考 虑要处理任务的特点和硬件环境，来事先设置的。 当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线 程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？ <br></p><p>我们一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞 的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队 的请求呢？ 我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储 排队请求。我们前面说过，队列有基于链表和基于数组这两种实现方式。这两种实现方式对 于排队请求又有什么区别呢？ 基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但 是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏 感的系统，基于链表实现的无限排队的线程池是不合适的。 而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的 请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就 相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的 请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。 除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中， 用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资 源时，基本上都可以通过“队列”这种数据结构来实现请求排队。 <br></p><h2 id="双端队列deque" tabindex="-1"><a class="header-anchor" href="#双端队列deque" aria-hidden="true">#</a> 双端队列Deque</h2><p>基本实现 可以利⽤⼀个双链表 队列的头尾两端能在 O(1) 的时间内进⾏数据的查看、添加和删除 <br> 常⽤场景：实现⼀个⻓度动态变化的窗⼝或者连续区间 <br></p><h2 id="单调队列" tabindex="-1"><a class="header-anchor" href="#单调队列" aria-hidden="true">#</a> 单调队列</h2><p>元素按从小到大或从大到小排列，具有单调性 <br></p>',8),b=[n];function c(i,o){return r(),a("div",null,b)}const s=e(d,[["render",c],["__file","4.队列.html.vue"]]);export{s as default};
