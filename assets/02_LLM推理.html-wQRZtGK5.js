const e=JSON.parse('{"key":"v-8e42aaf0","path":"/llm/04_llm_reasoning/02_LLM%E6%8E%A8%E7%90%86.html","title":"LLM推理","lang":"en-US","frontmatter":{"icon":"lightbulb","description":"LLM推理 1. 解码效率的定量评估指标 GPU性能评估 GPU算力 : 算力是指 GPU 每秒能够进行的浮点运算次数，单位是 FLOP/s GPU带宽 : 带宽是该显卡每秒能够进行的显存读写量，单位是 byte/s GPU计算强度上限 : 算力和带宽的比值被称为该 GPU 的计算强度上限 𝐼𝑚𝑎𝑥，单位为 FLOP/byte 模型性能评估 模型的运算量 : 运算量是指运行该模型需要的总浮点计算数，单位为 FLOP 模型的访存量 : 访存量是运行该模型的过程中所需的显存读写量，单位为 byte 模型的计算强度 : 运算量和访存量的比值被称为该模型的计算强度 𝐼，单位为 FLOP/byte 带宽瓶颈和计算瓶颈 带宽瓶颈 / 显存瓶颈 当模型的计算强度 𝐼 小于GPU 的计算强度上限 𝐼𝑚𝑎𝑥 时，这说明 GPU 的理论最高显存读写速度低于实际运算所需速度，因此模型实际的运行效率将主要受到显存读写速度的影响，这种情况称为带宽瓶颈； 反之，当 𝐼 大于 𝐼𝑚𝑎𝑥 时，说明 GPU 的理论最高浮点运算速度低于实际运算所需速度，因此模型的运行效率将主要受到算力的影响，这种情况称为计算瓶颈。","head":[["meta",{"property":"og:url","content":"https://liz-in-tech.github.io/pinkpig/llm/04_llm_reasoning/02_LLM%E6%8E%A8%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Liz"}],["meta",{"property":"og:title","content":"LLM推理"}],["meta",{"property":"og:description","content":"LLM推理 1. 解码效率的定量评估指标 GPU性能评估 GPU算力 : 算力是指 GPU 每秒能够进行的浮点运算次数，单位是 FLOP/s GPU带宽 : 带宽是该显卡每秒能够进行的显存读写量，单位是 byte/s GPU计算强度上限 : 算力和带宽的比值被称为该 GPU 的计算强度上限 𝐼𝑚𝑎𝑥，单位为 FLOP/byte 模型性能评估 模型的运算量 : 运算量是指运行该模型需要的总浮点计算数，单位为 FLOP 模型的访存量 : 访存量是运行该模型的过程中所需的显存读写量，单位为 byte 模型的计算强度 : 运算量和访存量的比值被称为该模型的计算强度 𝐼，单位为 FLOP/byte 带宽瓶颈和计算瓶颈 带宽瓶颈 / 显存瓶颈 当模型的计算强度 𝐼 小于GPU 的计算强度上限 𝐼𝑚𝑎𝑥 时，这说明 GPU 的理论最高显存读写速度低于实际运算所需速度，因此模型实际的运行效率将主要受到显存读写速度的影响，这种情况称为带宽瓶颈； 反之，当 𝐼 大于 𝐼𝑚𝑎𝑥 时，说明 GPU 的理论最高浮点运算速度低于实际运算所需速度，因此模型的运行效率将主要受到算力的影响，这种情况称为计算瓶颈。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-03-29T07:33:01.000Z"}],["meta",{"property":"article:author","content":"Liz"}],["meta",{"property":"article:modified_time","content":"2025-03-29T07:33:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"LLM推理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-29T07:33:01.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Liz\\",\\"url\\":\\"https://github.com/liz-in-tech\\"}]}"]]},"headers":[{"level":2,"title":"1. 解码效率的定量评估指标","slug":"_1-解码效率的定量评估指标","link":"#_1-解码效率的定量评估指标","children":[]},{"level":2,"title":"2. 自回归生成算法","slug":"_2-自回归生成算法","link":"#_2-自回归生成算法","children":[]},{"level":2,"title":"3. 全量解码阶段与增量解码阶段","slug":"_3-全量解码阶段与增量解码阶段","link":"#_3-全量解码阶段与增量解码阶段","children":[{"level":3,"title":"3.1. 全量解码阶段 / 预填充阶段（第一次）- 计算瓶颈","slug":"_3-1-全量解码阶段-预填充阶段-第一次-计算瓶颈","link":"#_3-1-全量解码阶段-预填充阶段-第一次-计算瓶颈","children":[]},{"level":3,"title":"3.2. 增量解码阶段 / 解码阶段（之后多次）- 带宽瓶颈/显存瓶颈","slug":"_3-2-增量解码阶段-解码阶段-之后多次-带宽瓶颈-显存瓶颈","link":"#_3-2-增量解码阶段-解码阶段-之后多次-带宽瓶颈-显存瓶颈","children":[]}]},{"level":2,"title":"4. 增量解码阶段（显存瓶颈）的改进方法","slug":"_4-增量解码阶段-显存瓶颈-的改进方法","link":"#_4-增量解码阶段-显存瓶颈-的改进方法","children":[{"level":3,"title":"4.1. 系统优化（直接解决系统级别的内存墙问题）","slug":"_4-1-系统优化-直接解决系统级别的内存墙问题","link":"#_4-1-系统优化-直接解决系统级别的内存墙问题","children":[]},{"level":3,"title":"4.2. 解码策略优化（针对自回归解码策略的改进方法）","slug":"_4-2-解码策略优化-针对自回归解码策略的改进方法","link":"#_4-2-解码策略优化-针对自回归解码策略的改进方法","children":[]}]}],"git":{"createdTime":1743233581000,"updatedTime":1743233581000,"contributors":[{"name":"liz","email":"liz@MacBook-Pro-2.local","commits":1}]},"readingTime":{"minutes":4.6,"words":1381},"filePathRelative":"llm/04_llm_reasoning/02_LLM推理.md","localizedDate":"March 29, 2025","excerpt":"<h1> LLM推理</h1>\\n<h2> 1. 解码效率的定量评估指标</h2>\\n<ul>\\n<li>GPU性能评估\\n<ul>\\n<li>GPU算力 : 算力是指 GPU 每秒能够进行的浮点运算次数，单位是 FLOP/s</li>\\n<li>GPU带宽 : 带宽是该显卡每秒能够进行的显存读写量，单位是 byte/s</li>\\n<li>GPU计算强度上限 : 算力和带宽的比值被称为该 GPU 的计算强度上限 𝐼𝑚𝑎𝑥，单位为 FLOP/byte</li>\\n</ul>\\n</li>\\n<li>模型性能评估\\n<ul>\\n<li>模型的运算量 : 运算量是指运行该模型需要的总浮点计算数，单位为 FLOP</li>\\n<li>模型的访存量 : 访存量是运行该模型的过程中所需的显存读写量，单位为 byte</li>\\n<li>模型的计算强度 : 运算量和访存量的比值被称为该模型的计算强度 𝐼，单位为 FLOP/byte</li>\\n</ul>\\n</li>\\n<li>带宽瓶颈和计算瓶颈\\n<ul>\\n<li>带宽瓶颈 / 显存瓶颈\\n<ul>\\n<li>当模型的计算强度 𝐼 小于GPU 的计算强度上限 𝐼𝑚𝑎𝑥 时，这说明 GPU 的理论最高显存读写速度低于实际运算所需速度，因此模型实际的运行效率将主要受到显存读写速度的影响，这种情况称为带宽瓶颈；</li>\\n</ul>\\n</li>\\n<li>反之，当 𝐼 大于 𝐼𝑚𝑎𝑥 时，说明 GPU 的理论最高浮点运算速度低于实际运算所需速度，因此模型的运行效率将主要受到算力的影响，这种情况称为计算瓶颈。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
