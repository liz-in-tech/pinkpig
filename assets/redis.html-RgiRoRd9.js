const e=JSON.parse('{"key":"v-1711ecd4","path":"/middleware/redis/redis.html","title":"Redis","lang":"en-US","frontmatter":{"icon":"lightbulb","description":"Redis Redis为什么快 基于内存运行 c语言实现，更接近底层操作 源码精湛简短 数据结构专门设计，底层做了优化 Redis是单线程（worker线程始终是单线程） Redis5.x版本及之前是单线程的工作机制，worker既处理IO又处理计算，按顺序串行执行。 Redis6.0版本之后，推出了多线程概念，多个IO子线程处理IO读写，worker仅处理计算，性能提高。 单线程与多线程适用场景 一个请求处理很快，但这个请求数量很多，适合用单线程。eg.redis存取key；nginx请求转发。","head":[["meta",{"property":"og:url","content":"https://liz-in-tech.github.io/pinkpig/middleware/redis/redis.html"}],["meta",{"property":"og:site_name","content":"Liz"}],["meta",{"property":"og:title","content":"Redis"}],["meta",{"property":"og:description","content":"Redis Redis为什么快 基于内存运行 c语言实现，更接近底层操作 源码精湛简短 数据结构专门设计，底层做了优化 Redis是单线程（worker线程始终是单线程） Redis5.x版本及之前是单线程的工作机制，worker既处理IO又处理计算，按顺序串行执行。 Redis6.0版本之后，推出了多线程概念，多个IO子线程处理IO读写，worker仅处理计算，性能提高。 单线程与多线程适用场景 一个请求处理很快，但这个请求数量很多，适合用单线程。eg.redis存取key；nginx请求转发。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-02-16T13:11:34.000Z"}],["meta",{"property":"article:author","content":"Liz"}],["meta",{"property":"article:modified_time","content":"2025-02-16T13:11:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-16T13:11:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Liz\\",\\"url\\":\\"https://github.com/liz-in-tech\\"}]}"]]},"headers":[{"level":2,"title":"Redis为什么快","slug":"redis为什么快","link":"#redis为什么快","children":[{"level":3,"title":"Redis是单线程（worker线程始终是单线程）","slug":"redis是单线程-worker线程始终是单线程","link":"#redis是单线程-worker线程始终是单线程","children":[]},{"level":3,"title":"IO多路复用（非阻塞IO）","slug":"io多路复用-非阻塞io","link":"#io多路复用-非阻塞io","children":[]}]},{"level":2,"title":"5种基础数据结构","slug":"_5种基础数据结构","link":"#_5种基础数据结构","children":[{"level":3,"title":"整体存储结构：全局哈希表","slug":"整体存储结构-全局哈希表","link":"#整体存储结构-全局哈希表","children":[]},{"level":3,"title":"5种","slug":"_5种","link":"#_5种","children":[]}]},{"level":2,"title":"持久化机制","slug":"持久化机制","link":"#持久化机制","children":[{"level":3,"title":"how","slug":"how","link":"#how","children":[]},{"level":3,"title":"性能建议","slug":"性能建议","link":"#性能建议","children":[]}]},{"level":2,"title":"过期键删除策略","slug":"过期键删除策略","link":"#过期键删除策略","children":[{"level":3,"title":"策略","slug":"策略","link":"#策略","children":[]}]},{"level":2,"title":"内存淘汰机制（逐出算法）","slug":"内存淘汰机制-逐出算法","link":"#内存淘汰机制-逐出算法","children":[{"level":3,"title":"分类","slug":"分类","link":"#分类","children":[]}]},{"level":2,"title":"集群方案","slug":"集群方案","link":"#集群方案","children":[{"level":3,"title":"方案","slug":"方案","link":"#方案","children":[]}]},{"level":2,"title":"主从复制（全量复制&增量复制）","slug":"主从复制-全量复制-增量复制","link":"#主从复制-全量复制-增量复制","children":[]},{"level":2,"title":"事务实现","slug":"事务实现","link":"#事务实现","children":[]},{"level":2,"title":"缓存雪崩、缓存穿透与缓存击穿","slug":"缓存雪崩、缓存穿透与缓存击穿","link":"#缓存雪崩、缓存穿透与缓存击穿","children":[{"level":3,"title":"缓存雪崩","slug":"缓存雪崩","link":"#缓存雪崩","children":[]},{"level":3,"title":"缓存击穿","slug":"缓存击穿","link":"#缓存击穿","children":[]},{"level":3,"title":"缓存穿透","slug":"缓存穿透","link":"#缓存穿透","children":[]}]},{"level":2,"title":"如何保证Redis和Mysql数据一致","slug":"如何保证redis和mysql数据一致","link":"#如何保证redis和mysql数据一致","children":[{"level":3,"title":"一致性分类","slug":"一致性分类","link":"#一致性分类","children":[]},{"level":3,"title":"不一致的场景","slug":"不一致的场景","link":"#不一致的场景","children":[]},{"level":3,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[]}]},{"level":2,"title":"使用","slug":"使用","link":"#使用","children":[]}],"git":{"createdTime":1730220137000,"updatedTime":1739711494000,"contributors":[{"name":"liz","email":"liz@MacBook-Pro.local","commits":2},{"name":"unknown","email":"15721607377@163.com","commits":1}]},"readingTime":{"minutes":14.43,"words":4329},"filePathRelative":"middleware/redis/redis.md","localizedDate":"October 29, 2024","excerpt":"<h1> Redis</h1>\\n<h2> Redis为什么快</h2>\\n<p>基于内存运行</p>\\n<p>c语言实现，更接近底层操作</p>\\n<p>源码精湛简短</p>\\n<p>数据结构专门设计，底层做了优化</p>\\n<h3> Redis是单线程（worker线程始终是单线程）</h3>\\n<p>Redis5.x版本及之前是单线程的工作机制，worker既处理IO又处理计算，按顺序串行执行。</p>\\n<p>Redis6.0版本之后，推出了多线程概念，多个IO子线程处理IO读写，worker仅处理计算，性能提高。</p>\\n<h4> 单线程与多线程适用场景</h4>\\n<p>一个请求处理很快，但这个请求数量很多，适合用单线程。eg.redis存取key；nginx请求转发。</p>","autoDesc":true}');export{e as data};
