---
icon: lightbulb
---
# 链表
## 链表分类
### 单链表
每个结点由两部分组成，data和next。 <br/>
特殊结点：头结点、尾结点 <br/>
头结点：第一个结点，用来记录链表的基地址，有了它，我们就可以遍历得到整条链表。 <br/>
尾结点：指针指向空地址NULL，表示这是链表上最后一个结点。 <br/>
### 循环链表
循环链表与单链表的区别，仅在于尾结点，尾结点指针指向链表的头结点，适合处理环形结构的数据。 <br/>
### 双向链表（在实际软件开发中更加常用）
每个结点由三部分组成，数据data，后继指针next，前驱指针prev。 <br/>
特点： <br/>
占用更多存储空间，支持两个方向，更灵活。 <br/>
支持O(1)找到前驱结点。在需要用到上一个结点时，用双向链表可以很容易知道上一个结点，而用单链表，需要用双指针，保留上一个结点和当前结点的位置。插入和删除当前结点，都需要用到上一个结点。 <br/>
查找有序链表时，可以根据要查找的值决定往前还是往后找。 <br/>
Java中，双向链表的应用：LinkedList、LinkedHashMap <br/>
#### 用空间换时间的设计思想
对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。 <br/>
双向链表就是用空间换时间。 <br/>
缓存也是用空间换时间的设计思想。 通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询，不需要都去访问硬盘，速度就大大提高了。 <br/>
### 双向循环链表 
循环链表和双向链表的结合 <br/>
## 数组vs链表
|  | 数组 | 链表 |
| --- | --- | --- |
| 随机访问复杂度 | O(1) | O(n) |
| 插入删除复杂度 | O(n) | O(1) |
| 是否可以借助CPU缓存机制 | 可以，预读数组，访问效率更高 | 不可以 | <br/>
| 优点 | 如果你的代码对内存的使用非常苛刻，那数组就更适合你。 | 链表本身没有大小的限制，天然地支持动态扩容。 |
| 缺点 | 数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。就算ArrayList可以动态扩容，但扩容耗时很大。 | 链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。 |

## 链表应用：LRU缓存淘汰算法
1）缓存淘汰策略 <br/>
缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。  <br/>
缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out，按放入顺序）、最少使用策略 LFU（Least Frequently Used，按使用次数）、最近最少使用策略 LRU（Least Recently Used，按使用时间）。  <br/>
2）如何用链表实现LRU缓存淘汰策略 <br/>
维护一个有序单链表，从头到尾按最新访问时间从近到远排列，访问越靠头结点的越近访问，访问越靠尾结点的越久访问。 <br/>
当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。   <br/>

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从 原来的位置删除，然后再插入到链表的头部。   <br/>
2.  如果此数据没有在缓存链表中，又可以分为两种情况： <br/>
   1. 如果此时缓存未满，则将此结点直接插入到链表的头部 <br/>
   2. 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部   <br/>

 LRU基于链表的实现思路，缓存访问的时间复杂度为 O(n)     <br/>
3）引入散列表优化 <br/>
引入散列表来记录每个数据的位置，可将缓存访问的时间复杂度降到O(1) <br/>
4）如何用数组实现LRU缓存淘汰策略 <br/>
## 链表解题技巧
### 技巧一：利用哨兵（头结点）简化实现难度，减少特殊处理
如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫**带头链表**。相反，没有哨兵结点的链表就叫作**不带头链表**。哨兵结点不存数据， 因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。   <br/>
Note：如果没有哨兵结点，则添加第一个和删除最后一个与其他操作不一样。 <br/>
Note：实际上，这种利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、 归并排序、动态规划等。   <br/>
Note：哨兵可以理解为它可以减少特殊情况的判断，比如判空，越界，链表判空的判断等。 <br/>
### 技巧二：利用快慢指针（有时用到3个指针）
找中间节点：快慢指针，让快指针每次走两步，让慢指针每次走一步 <br/>

找倒数第k个节点：快慢指针，先让快指针走k步，然后快慢指针一起向后移动，直到快指针移到最后，慢指针处就能找到第k个 <br/>

检测是否有环：快慢指针，让快指针每次走两步，让慢指针每次走一步，如果有环，两个指针一定会在某个节点相遇 <br/>

检测环的入口：
1）快慢指针，让快指针每次走两步，让慢指针每次走一步，如果有环，两个指针一定会在某个节点相遇
2）此时，让快指针回到原点，快慢指针都一步一步走，会在环的入口相遇<br>
Note1:不需要哨兵节点  <br>
Note2:该方法依据是公式推演得出的，设环外长a,环内相遇前长b,环内相遇后长c,那么b+c为环的长度，以及快指针走的距离是慢指针的2倍
a+n(b+c)+b=2(a+b) => (n-1)(b+c) + c = a
### 技巧三：删除当前节点，但不知道上一个节点
把下一个节点的值赋值给当前节点，把下一个节点删除 <br/>
### 技巧四：重点留意边界条件处理
经常用来检查链表代码是否正确的边界条件有这样几个：  <br/>
如果链表为空时，代码是否能正常工作？  <br/>
如果链表只包含一个结点时，代码是否能正常工作？  <br/>
如果链表只包含两个结点时，代码是否能正常工作？  <br/>
代码逻辑在处理头结点和尾结点的时候，是否能正常工作？   <br/>
Note：针对不同场景，可能还有特定的边界条件 <br/>
### 技巧五：举例画图，辅助思考
### 技巧六：多写多练，没有捷径
5 个常见的链表操作   <br/>
单链表反转  <br/>
链表中环的检测  <br/>
两个有序的链表合并  <br/>
删除链表倒数第 n 个结点  <br/>
求链表的中间结点   <br/>
## 链表算法题型
### 一、需要找到单链表中指定节点的位置
#### （一）算法题目
##### 1、返回一个链表的倒数第k个节点
**思路** <br/>
找倒数第k个：快慢指针，先让快指针走k步，然后快慢指针一起向后移动，直到快指针移到最后，慢指针处就能找到第k个 <br/>
**复杂度分析** <br/>
**代码实现** <br/>
##### **2、求链表的中间结点**
**思路** <br/>
找中间节点：快慢指针，让快指针每次走两步，让慢指针每次走一步 <br/>
**复杂度分析** <br/>
**代码实现** <br/>
##### 3、删除链表的倒数第n个节点
**思路** <br/>
**复杂度分析** <br/>
**代码实现** <br/>
##### 4、旋转链表（向右移动k个位置）
**思路** <br/>
遍历第一次：确定链表长度l，把最后链表的next设为head <br/>
遍历第二次：对k取模，从头向右移动l-k-1，把当前节点的next保留为move节点后设为null，返回move节点 <br/>
**复杂度分析** <br/>
**代码实现** <br/>
##### 5、重排链表
**思路** <br/>
**复杂度分析** <br/>
**代码实现** <br/>
##### 6、回文链表
字符串用单链表存储，如何判断是否是回文字符串? 时间复杂度是多少呢？ <br/>
**思路** <br/>
**复杂度分析** <br/>
**代码实现** <br/>
#### （二）解题思路
1.找到倒数第k个 <br/>
快慢指针：先让快指针走k步，然后让快慢指针一起向后移动 <br/>
2.找到中间节点 <br/>
快慢指针：让快指针每次走两步，让慢指针每次走一步 <br/>
### 二、环形链表
#### （一）算法题目
##### 1、判断链表是否有环
**思路** <br/>
**复杂度分析** <br/>
**代码实现** <br/>
##### 2、链表中环的大小
**思路** <br/>
**复杂度分析** <br/>
**代码实现** <br/>
##### 3、链表中环的入口结点
**思路** <br/>
**复杂度分析** <br/>
**代码实现** <br/>
#### （二）解题思路
快慢指针：让快指针每次走两步，让慢指针每次走一步，如果有环，两个指针一定会在某个节点相遇 <br/>
### 三、链表排序&合并链表
#### （一）算法题目
##### 1、链表排序
**思路** <br/>
**复杂度分析** <br/>
**代码实现** <br/>
##### 2、合并两个有序链表
**思路** <br/>
**复杂度分析** <br/>
**代码实现** <br/>
##### 3、合并k个有序链表
**思路** <br/>
**复杂度分析** <br/>
**代码实现** <br/>
#### （二）解题思路
归并排序：对链表进行归并排序，我们首先要找到链表的中点将链表分成两部分，对这两部分链表进行排序。然后分别在对链表的这两部分重复前面的动作，直到结束。 <br/>
合并k个有序链表利用Java中的优先队列PriorityQueue来实现 <br/>
### 四、翻转链表
#### （一）算法题目
##### 1、[单链表翻转](https://leetcode-cn.com/problems/reverse-linked-list/)	
**思路** <br/>
pre为翻转好的，cur为未翻转的，均向右移动，最后返回pre即为翻转结果。 <br/>
**复杂度分析** <br/>
时间复杂度：O(n) <br/>
空间复杂度：O(1) <br/>
**代码实现** <br/>
```shell
class Solution { <br/>
    public ListNode reverseList(ListNode head) { <br/>
        ListNode pre = null; <br/>
        ListNode cur = head; <br/>
        while (cur != null) { <br/>
            ListNode next = cur.next; //保留cur的下一个节点 <br/>
            cur.next = pre; //cur.next赋值为已反转好的头节点pre <br/>
            pre = cur; //更新头结点为cur <br/>
            cur = next; //下一个节点作为cur <br/>
        } <br/>
        return pre; <br/>
    } <br/>
} <br/>
```
##### 2、[k个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/submissions/) 
**思路** <br/>
定义四个节点，pre,start,end,next. <br/>
1.定义整个链表头节点（也就是在前面加哨兵节点） <br/>
2.pre为上段尾节点，end为当前段尾节点，初始均指向整个链表头节点，也就是上一段的尾节点。 <br/>
3.让end移动到当前段尾节点位置 <br/>
4.更新start和next节点 <br/>
start为当前段头节点，可由pre.next得到 <br/>
next为下段头节点，可由end.next得到 <br/>
5.然后切断下段(不需要切断上段，只需切断下段)，进行翻转，翻转后再连上下段，更新pre和end节点 <br/>
**复杂度分析** <br/>
时间复杂度：O(n) <br/>
空间复杂度：O(1) <br/>
**代码实现** <br/>
```shell
/** <br/>
 * Definition for singly-linked list. <br/>
 * public class ListNode { <br/>
 *     int val; <br/>
 *     ListNode next; <br/>
 *     ListNode() {} <br/>
 *     ListNode(int val) { this.val = val; } <br/>
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } <br/>
 * } <br/>
 */ <br/>
class Solution { <br/>
    public ListNode reverseKGroup(ListNode head, int k) { <br/>
        //加头节点 <br/>
        ListNode h = new ListNode(0,head); <br/>
        //定义四个节点 pre start end next <br/>
        //pre和end为上一段的尾节点 <br/>
        ListNode pre = h, end = h; <br/>
        while(end != null){ <br/>
            //end移到当前段的尾节点 <br/>
            for(int i = 0; i < k && end != null; i++){ <br/>
                end = end.next; <br/>
            } <br/>
            if(end == null)break;  <br/>
            //pre的下一个是start；end的下一个是next <br/>
            ListNode start = pre.next; <br/>
            ListNode next = end.next;  <br/>
            //切断与下一段的联系 <br/>
            end.next = null; <br/>
            //翻转当前段 <br/>
            pre.next = reverse(start); <br/>
            //连接下一段 <br/>
            start.next = next; <br/>
            //更新pre和end为上一段的尾节点 <br/>
            pre = start; <br/>
            end = start;      <br/>
        } <br/>
        return h.next; <br/>
    } <br/>

    private ListNode reverse(ListNode head){ <br/>
        ListNode pre = null; <br/>
        ListNode cur = head; <br/>
        while(cur != null){ <br/>
            ListNode next = cur.next; <br/>
            cur.next = pre; <br/>
            pre = cur; <br/>
            cur = next; <br/>
        } <br/>
        return pre; <br/>
    } <br/>
} <br/>
```
##### 3、翻转指定节点位置的链表
**思路** <br/>
**复杂度分析** <br/>
**代码实现** <br/>
##### 4、两两交换链表中的节点
**思路** <br/>
**复杂度分析** <br/>
**代码实现** <br/>
##### 5、链表整体翻转（递归&迭代）
**思路** <br/>
**复杂度分析** <br/>
**代码实现** <br/>
#### （二）解题思路
找到需要交换的节点位置 <br/>
找到需要交换节点的前驱和后继节点 <br/>
节点交换 <br/>
### 五、从尾到头打印链表（递归和非递归）
**思路** <br/>
**复杂度分析** <br/>
**代码实现** <br/>
